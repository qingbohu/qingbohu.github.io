[{"title":"无须联网激活系统工具","url":"/2021/05/07/无须联网激活系统工具/","content":"### 软件介绍\nHEU KMS Activator 是一位叫 知彼而知己 的大神所开发的KMS激活工具，最新版本新增加了OEM激活，增加对Vista/Win7/Server 2008 (R2)/2012 (R2) OEM的永久激活(支持Legacy/UEFI BIOS)，此工具可以完美的激活Windows以及Office的VL版本，无需联网即可一键激活，目前最新版的HEU KMS Activator 新增Win10数字许可证激活，不在是以前的那个KMS激活了，很多系统都可以使用数字权利永久激活使用，而且此工具带有静默激活参数可以用来封装使用，在封装系统安装后调用HEU KMS Activator 计划任务 加上静默激活参数可完美激活，此版本激活成功率最高，推荐系统封装爱好者使用，此工具由亿破姐收集整理100%出自“知彼而知己”的正版，无广告，无流氓行为，无捆绑，无后门的激活工具。\n### 下载地址\nhttps://wwr.lanzous.com/i9ilBowio2f\n密码:gbtz","tags":["工具分享"],"categories":["工具分享","激活软件","Windows无须联网激活工具"]},{"title":"网站使用介绍","url":"/2021/05/06/网站使用介绍/","content":"## 前言\n非常幸运能得到您的访问，希望我的博客能给您带来帮助。在博客我主要分享自己在学习路上所遇到的坎坷、学习笔记分享、常用的工具分享、生活日记等。如果您在使用过程遇到问题或文章中出现错误，欢迎您给你提出宝贵的意见。\n\n\n## 网站使用说明\n\n1. 网站使用 hexo 框架搭建的部署在 github 中\n\n2. 如何查找文章？\n- 点击网站右上角搜索可以对文章进行检索\n![image-20210421161046575](/images/sysm.png)\n3. 首页文章太杂乱了。找不到我想看的类型？\n- 点击网站导航中的 __文章分类__ 可以对文章进行分类查看\n![image-20210421161046575](/images/wzfl.png)\n\n","tags":["网站使用介绍"],"categories":["网站使用介绍"]},{"title":"XMind脑图软件","url":"/2021/05/06/XMind脑图软件/","content":"## 软件介绍\n我经常拿这个软件来记笔记，非常不错的软件，分享给大家。XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。XMind ZEN具有强大的绘图基础，除了常规的组织结构图、逻辑图、鱼骨图、矩阵图之外，还可以发挥自己的想象力，通过简单的自由主题和主题间的联系，打破思维导图的固有模式，画出极具创意的结构模式。\n## 下载地址\n蓝奏云：\nhttps://wwr.lanzous.com/b0263xa3i\n密码:e0kf","tags":["工具分享"],"categories":["工具分享","办公软件","XMind思维导图软件"]},{"title":"Office系列软件","url":"/2021/05/06/office系列软件/","content":"### 应用介绍\noffice 2019 \n### 下载地址\n链接: https://pan.baidu.com/s/159n4RyG7SGumNvhtCf0fqA 提取码: 4iry 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","办公软件","Office 全系列软件"]},{"title":"adobe系列软件","url":"/2021/05/06/adobe系列软件/","content":"### 应用介绍\n软件内涵盖所有欧特比系列的全新软件，并贴心的分为大师版光盘镜像和独立版软件，将可独立安装的SP版和体积较大的大师版都打包了进去。所有产品都免激活，集破解补丁于一体，一键安装即可使用，无需复杂的操作，支持自定义选择简体中文、安装路径设置，十分方便。需要注意的是软件因配置需求因素，需要安装在最新的最新的Windows 10系统上面，并需要配置高性能硬盘，并保存足够的剩余空间。小编分享的赢政天下Adobe2021大师版，有专业需求的不妨下载收藏。\n### 下载地址\n链接: https://pan.baidu.com/s/1z4gnkfRA5bMClg-DsKmc5g 提取码: siy7 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","制图工具","Adobe2020全系列软件"]},{"title":"深入理解原型链与继承","url":"/2021/05/06/深入理解原型链与继承/","content":"## 构造函数、原型对象、实例三者之间的关系\n- 构造函数  =\\=\\=\\= prototype=\\=\\=\\=>  原型对象\n- 原型对象 =\\=\\=\\=constructor =\\=\\=\\=> 构造函数\n- 实例 =\\=\\=\\= \\_\\_proto\\_\\_ =\\=\\=\\=> 原型对象 \n\n借助一张图来理解：\n![image-20210421161046575](/images/yxl.png)\n\n## 重写原型对象\n应用场景：在实现某一功能时，经常会用一个包含所有属性和方法重写整个原型对象。（因为添加的方法或属性很少那么只需要在原型对象上添加。其实在工作中更多的是在原型对象的基础上添加属性或方法，而不重写整个原型对象）\n\n重写整个原型对象：\n```javascript\nPerson.prototype = {\n    name: \"神奇的程序员\",\n    age: \"20\",\n    job: \"web前端开发\",\n    sayName: function () {\n        console.log(this.name);\n    }\n    constructor: Person\n}\n```\n\n在原型对象上添加属性或方法\n```javascript\nPerson.protutypt.name = \"神奇的程序员\"\nPerson.protutypt.age = \"20\"\nPerson.protutypt.sayName = function(){\n\tconsole.log(this.name)\n}\n\n```\n- 两种方法作用其实是一样的。重写整个原型对象如果不手动设置 constructor 属性那么它的 constructor 属性会指向 Object （正常情况应该指向对应的构造函数）\n\n## 原型链\n\n1. 当访问一个对象的成员(属性或方法),首先查找这个对象自身有没有该成员\n2. 在该对象中没有查找该成员,查找在它的原型对象是否有该成员(\\_\\_prototype\\_\\_指向原型对象)\n3. 原型对象上没有查找该成员,在 Object 的原型对象查找\n4. 还是没有找到 返回 Null\n- 以上四部构成了原型链,只要在任意一层找到了就执行该成员,没有都找到返回 Null\n\n## 原型对象继承\n\n- 每个构造函数都有一个原型对象\n- 原型对象都有 constructor 属性它是指向构造函数（被重写原型对象除外，没有手动指回原型对象的，默认指向 Object ）\n- 每个构造函数通过 \\_\\_proto\\_\\_ 指向原型对象\n\n原型链继承就是一个构造函数原型对象等于另一个构造函数的实例，此时的原型对象将包含一个指向另一个构造函数原型的指针。下面的例子 Sub 构造函数 的原型对象重写成了 Super 实例。Sub 可以调用调用 Super 的原型对象上的方法，这就组成了一条原型链。 \n\n```javascript\nfunction Super() {\n  this.superStatus = true\n}\n// 在原型对象上添加方法\nSuper.prototype.getSuperStatus = function() {\n  return this.superStatus\n}\nfunction Sub() {\n  this.subStatus = false\n}\n// 在原型对象上添加方法\nSub.prototype.getSubStatus = function() {\n  return this.subStatus\n}\n// 将 Sub 原型对象指向 Super 实例 此时constructor 被重写 指向 Super\nSub.prototype = new Super()\n\n// 实例化 Sub\nvar sub = new Sub()\n// sub 实例没有 getSuperStatus 方法 但是因为我们之前它的原型对象重写指向了 Super \nconsole.log('获取Super的属性值',sub.getSuperStatus()) // outPut: 获取Super的属性值 true\n```\n### 原型链继承存在的问题\nSub 的原型对象重写成 Super 的实例，Sub 继承 Super 的全部属性和方法。我们需求是在 实例 sub1 上添加的数据，但是后面的 sub2 也受到了影响。这就是存在的问题。\n```javascript\nfunction Super() {\n  this.list = [\"a\",\"b\",\"c\"];\n}\n\nfunction Sub() {\n\n}\nSub.prototype = new Super();\nconst sub1 = new Sub();\nsub1.list.push(\"d\");\nconsole.log(sub1.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\nconst sub2 = new Sub();\nconsole.log(sub2.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\n```\n## 类\n\n在 ES6 之前 JavaScript 是没有类的概念，都是用 构造函数来代替类的作用。类的出现极大的简化操作，\n### 类的语法\n\n- 创建类\n```javascript\n// 创建类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\t// 类的方法\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\nf1 = new Fathe('张三', 20)\nconsole.log(f1.name, f1.age) // outPut: 张三 20\n```\n### 类的继承\n\n构造函数和类的作用都用来实例化对象的。使对象之间有关联性，而类的优点在于更加方便的创建继承，不需要想构造函数那样使用 寄生式继承、修改原型对象指向继承、构造函数静态方法继承。但是 类的底层实现方法还是基于构造函数的方法。\n\n实例\n\n```javascript\n// 创建父类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\n// 创建子类 使用 extends 继承父类 \nclass Children extends Fathe {\n  constructor(name,age, sex) {\n    // 继承父类的 ane age 属性 \n      // super 要写 this 最前面\n    super(name, age) \n    this.sex = sex\n  }\n}\n\nvar children1 = new Children('李四', 20, '男')\nchildren1.say()  // 子类调用父类的方法\nconsole.log(children1) \n```\n\n\n\n\n\n\n","tags":["原型链与继承"],"categories":["前端基础知识","原型链与继承"]},{"title":"常见数组遍历方法","url":"/2021/05/04/数组常见操作方法/","content":"- 说明：\n1. 书写顺序按实际工作中使用的频率排序。\n2. 参数中出现 [] (中括号) 表示在为可选参数\n\n# 常见的数组遍历方法\n## 一、forEach 方法\nforEach 是最常见的数组遍历方法，使用简单功能单一。就是遍历数组的每一个元素\n### 语法\n全部参数：\n```javascript\narray.forEach(callback(current[, currentIndex, currentArray]){\n  console.log(current)\n}[, thisArg])\n```\n精简参数\n```javascript\narray.forEach(callback(current){\n  console.log(current)\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`forEach` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = ['张三', '李四', '王五']\narray.forEach((current, currentIndex, currentArray)=>{\n    console.log('当前被遍历的元素为：',current)\n    console.log('当前被遍历的元素下标为：',currentIndex)\n    console.log('当前被遍历的元素的数组对象：',currentArray)\n    console.log('回调函数中的this指向为：',this)\n    console.log('-----------------------------')\n},window)\n```\n--------------------------------------------------------------------------------------------------\n## 二、map 方法\nmap 方法可以用数组元素的映射，该方法不会改变源数组的值返回一个新的数组，参数和 forEach 函数是一样的。区别：因为 map 方法会返回一个全新的数组，那么在回调函数要使用 return 将当前元素返回。 \n### 语法\n全部参数：\n```javascript\narray.map(callback(current[, currentIndex, currentArray]){\n  return current + 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.map(callback(current){\n  return current + 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`map` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\n// 将原来的数组每个元素 + 10 返回\nvar array = [1, 2, 3, 4]\nvar result = array.map((current)=>{\n    return current + 10\n})\nconsole.log(result) // outPut: [11, 12, 13, 14]\n```\n--------------------------------------------------------------------------------------------------\n## 三、filter 方法\nfilter 方法是对数组元素进行筛选，将符合条件的元素返回成一个数组 和 map 方法 用法差不多 偶读需要 return 它们作用不同\n### 语法\n全部参数：\n```javascript\narray.filter(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.filter(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`filter` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.filter((current)=>{\n    return current > 30\n})\nconsole.log(result) // outPUt: [33, 78, 60]\n```\n---------------------------------------------------------------------------------------------------------\n## 四、some 方法\nsome 方法 测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值, 有无元素符合条件 有:返回 ture 无:返回flase\n### 语法\n全部参数：\n```javascript\narray.some(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.some(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`some` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.some((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: true\n```\n------------------------------------------------------------------------------------------------------\n## 五、every 方法\nevery 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n### 语法\n全部参数：\n```javascript\narray.every(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.every(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`every` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.every((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: false\n```\n## 六、reduce 方法\nreduce 方法虽然不常见但是用起来是最爽的一个，应用场景也非常多。例如 数组去重、统计字符出现的次数、扁平化数组。一般用于本次循环结果和下次循环结果有关联的场景。\n### 语法\n全部参数：\n```javascript\narray.reduce((total, current, currentIndex, currentArray) => {\n  return current \n},init)\n\n```\n精简参数：\n```javascript\narray.reduce((total, current) => {\n  return current \n})\n```\n`reduce` 一共接收两个参数 \n1. callback 每个元素执行的回调函数\n- total 累积器\n- current 当前元素\n- currentIndex 当前元素的下标\n- currentArray 当前元素的数组对象\n2. init 第一次执行回调函数时的初始值\n### 实例\n#### 一、数组去重\n```javascript\nvar array = [1, 1, 2, 2, 5, 5, 7, 7, 10, 10]\nvar result = array.reduce((total, current) => {\n    if (!total.includes(current)){\n        total.push(current)\n    }\n    return total\n},[])\nconsole.log(result) // outPut: [1, 2, 5, 7, 10]\n```\n#### 二、统计字符出现的次数\n```javascript\nvar str = 'asdihfsahf;shagfiohsagohsfjsdhfiusgfigasd'\nvar array = str.split('')\nvar result = array.reduce((total, current)=>{\n  if (total[current]) {\n    total[current]++\n  }else{\n    total[current] = 1\n  }\n  return total\n},{})\nconsole.log(result) // outPut: {a: 5, s: 8, d: 3, i: 4, h: 6, …} \n```","tags":["基础知识","数组遍历"],"categories":["前端基础知识","数组相关操作"]},{"title":"关于我","url":"/2021/05/01/关于我/","content":"### 首先非常感谢您阅读我的文章，世界之大能让您能看到我荣幸之至。\n### 个人标签：\n男、九九后、处女座、较真、正直、强迫症\n### 爱好：\n篮球、游戏、爬山、逛大佬博客网站、听前辈讲故事、用技术解决问题\n### 个人简介\n  目前在职 Web前端开发，真的十分庆幸能在自己喜欢的工作岗位上工作。首先感谢我的爸妈，这么多年对我的培养，虽然他们知识文化不高但是却给了我很好的生活和选择的权力，其次感恩老师，在叛逆期是老师的孜孜不倦的教诲才让我没有走错路，当很多人放弃了你却还有那么一个老师对你另眼相看给了你信心。在技术路上对我提供帮助的老师，通过你们的课程让我对技术有很多认识。\n\n  关于我：我一个非常简单的人，正如一个 API 你对我的输入，我也将会输出。性格开朗活泼，对技术充满向往和好奇。路漫漫其修远兮，吾将上下而求索。\n","tags":["关于我"],"categories":["生活日记"]}]