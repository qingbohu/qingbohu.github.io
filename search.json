[{"title":"正则表达式","url":"/2021/06/26/正则表达式/","content":"\n### 什么是正则表达式\n\n- 正则表达式是一个可以描述字符串模式的对象，使用正则表达式可以帮助我们验证用户输入的字符串是否符合程序需求。也可以在文本检索中发挥巨大的作用\n\n### 如何创建正则表达式\n\n- 可以通过 `RegExp` 对象来创建。通过 `RegExp()` 构造函数来创建正则表达式，不过更多情况我是使用**字面量**来创建正则表达式 \n\n示例：\n```js\n// RegExp 构造函的形式创建正则\nconst z = RegExp('^a')\n// 字面量的方式\nconst z1 = /^a/\n```\n\n以上两种方式创建的正则表达式描述的字符模式是相同的，只是创建的方法不同。\n\n### 字符类\n\n- 将直接量字符单独放入方括号内就组成了字符类，一个字符类看匹配到它所包括的任意字符。例如 `/[abc]/` 那么该正则可以匹配到字母 \"a\" 、\"b\"、\"c\" 中的任意一字符。\n\n示例：\n\n```js\nconst z = /[abc]/\nconsole.log(z.test('a')) // true\nconsole.log(z.test('b')) // true\nconsole.log(z.test('d')) // false 字符 d 并没有出现在字符类中所有是 false\n\n```\n\n\n- 如果将 `^` 放入方括号中例如 `/[^abc]/` 那么该正则表示匹配**除了** \"a\"、\"b\"\"、\"c\" 之外的所有字符\n\n```js\nconst z1 = /[^abc]/\nconsole.log(z1.test('a')) // false\nconsole.log(z1.test('b')) // false\nconsole.log(z1.test('d')) // true  当 ^ 出现在方括号中表示匹配除了字符类中的字符所有字符都可以匹配成功\n\n```\n\n- 字符类也可以使用连字符来表示字符范围 `/[a-z]/` 匹配所有的小写字母，`/[a-zA-Z0-9]/`表示匹配所有的字母和数字，下面介绍一些常见的字符类\n- [....] 匹配方括号内的任意字符\n- [^.....] 匹配不在方括号内的任意字符\n- \\w 匹配任何字母和数字 **等价**于[a-zA-Z0-9]\n- \\W 匹配除了所有字母和数组 **等价**于 \\[^a-zA-Z0-9]\n- \\s  匹配任何空白字符\n- \\S 匹配非空白字符\n- \\d 匹配数字 **等价**于 [0-9]\n- \\D 匹配非数字**等于** \\[^0-9] ","tags":["基础知识","正则表达式"],"categories":["前端基础知识","正则表达式"]},{"title":"2021-6-10日记","url":"/2021/06/10/2021-6-10日记/","content":"今天把加工资的消息告诉了妈妈，从她的复杂眼神中我可以看出，她内心真的非常的开心高兴激动，脸上露出藏不住的喜悦。说了一句给你读了这么多年书，总算没白读。————我要活成妈妈的骄傲 加油胡清波\n","tags":["关于我"],"categories":["生活日记"]},{"title":"JS实用小技巧","url":"/2021/06/07/JS实用小技巧/","content":"## 1. 立即执行函数\n一般在做业务的时候，都会有一个入口函数。例如\n\n```js\nfunction init(){\n    //...\n}\ninit()\n```\n其实可写成这种形式\n\n```js\n(function init(){\n    //...\n})()\n```\n好处：1. 拥有独立作用域 2.init函数没有必要再全局作用域下展示\n\n## 2. 变量类型转化\n\n在写代码时常会进行变量类型的转化 `parseInt()` `parseFloat()` 和 `toString()` 方法转化变量类型\n\n```js\nvar str = '10.9'\nconsole.log(typeof (parseFloat(str))) // outPut: number\nvar number = 66\nconsole.log(typeof (toString(number))) // outPut: string\n```\n其实也可以这么写，不仅容易记忆而且减少了代码量\n```js\nvar str = '10.9'\nconsole.log(typeof (str - 0)) // outPut: number\nvar number = 66\nconsole.log(typeof (number + '')) // outPut: string\n```\n\n## 3.短路操作\n\n没学会短路操作之前的代码\n\n```js\nif (!foo) {\n  foo = bar \n}\n\n```\n短路操作\n```js\nfoo = foo || bar \n```\n好处: 1. 代码量减少 2. 书写优雅\n\n短路原理记忆方法：\n在 JS 中 `&&` 和 `||` 都有一个共同的特性。\n `&&` 前后两个表达式，前为 false 后者不执行。 \n`||`前后两个表达式, 前为 true 后者不执行。\n\n## 4. 三元表达式\n\n三元表达式在每门语言中都会用到，没学之前会这么写\n\n```js\nif( a === true ) {\n  b = c\n} else {\n  b = d\n}\n```\n\n三元表达式可以这么写\n\n```js\nlet b = a ? c : d\n\n```\n\n优点： 1. 减少代码量 2. 优雅","tags":["前端基础知识","JS基础"],"categories":["前端基础知识","JS基础","JS小技巧"]},{"title":"vue基础知识","url":"/2021/06/06/vue基础知识/","content":"\n## 计算属性\n\n概述： 计算属性的出现是为了解决模板的简单运算，在模板中放入太多的逻辑会让模板难以维护例如：\n\n```html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\n在这个地方模板不在是简单的输出内容或声名逻辑，这里要显示变量`message`的翻转字符串。这样的写法后期很难维护。所以我们要将它写入到 **计算属性**中\n\n例子：\n```html\n<div id=\"example\">\n  <p>原始的 message: \"{{ message }}\"</p>\n  <p>计算后倒叙 message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n```js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n结果：\n```\n原始的 message: \"Hello\"\n\n计算后倒叙 message: \"olleH\"\n```\n注意点： computed(计算属性) 和 methods 可以实现相同功能，computed 和 methods 还是有区别，computed 计算一次会有缓存，如果被计算的属性值没有发生变化。computed 中的函数不会再执行计算，而是将缓存的结果返回。这样提高效率。而 methods 无论数值是否发生变化都会触发一次。 如果不希望有缓存可以用方法来代替。\n\n### 计算属性的 setter\n\n计算属性默认只有 getter，不过再需要时也可以提供一个 setter。\n\n什么是 getter 和 setter ？\n\n在我的理解 getter 是一个输出，将属性按照规则输出。setter 是一个输入。当手动改变了输出的值 setter 被触发。\n\n例子：\n\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n\n```\n现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新\n\n## 侦听属性\n\n侦听属性 `watch` 当有些数据需要随着其他数据变动而变动时，很容易滥用 `watch`。例如\n\n```html\n<div id=\"demo\">{{ fullName }}</div>\n```\n```js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n上述代码重复。计算属性，中的变量只要任何一个发生变化，就会重新计算值。监听与计算属性的进行比较：更适合\n\n```js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\n## Class 与 Style 的绑定\n\n### 对象语法\n\n可以传给 `v-bind:class` 一个对象，这样可以动态的切换 class：\n```html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n上面语法表示 `active` 这个 class 是否存在取决于数据 property `isActive` 布尔值。\n\n也可以在对象中传入多个字段来切换 多个class。此外 `v-bind:class` 指令也可以与普通的 class attribute 共存。\n\n```html\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n```js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n渲染结果为：\n```html\n<div class=\"static active\"></div>\n```\n绑定的数据对象不必内联定义在模块中，也可以写在`data` 中方便后期维护\n\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n```js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\n绑定的对象也可以是计算属性。\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n```js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n### 数组语法\n\n也可以把数组传给 `v-bind:class`\n```html\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n```\n```js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n渲染的结果为\n```\n<div class=\"active text-danger\"></div>\n```\n根据条件切换class，也可以用三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n数组中也可以使用对象语法。只有在 isActive 是 true 是才会添加 active 类 而 errorClass 始终存在\n```html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n## 列表渲染\n\n使用 `v-for`指令基于一个数组要渲染一个列表。`v-for` 还支持可选的第二个参数，时当前项的索引。\n```html\n<ul id=\"example-1\">\n  <li v-for=\"(item, index) in items\" :key=\"item.message\">\n    {{ item.message }} -- {{ index }}\n  </li>\n</ul>\n```\n```js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n结果\n- Foo\n- Bar\n\n也可以使用 `of` 代替 `in` 操作符 因为它更接近 JS 迭代器\n\n### `v-for` 里使用对象\n\n可以用 `v-for` 来遍历一个对象的\n\n```html\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n```js\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n```\n结果：\n- How to do lists in Vue\n- Jane Doe\n- 2016-04-10\n\n也可以提供第二个参数（也就是键名）：\n\n```html\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n```\n结果：\ntitle: How to do lists in Vue\nauthor: Jane Doe\npublishedAt: 2016-04-10\n\n还可以用第三个参数作为索引\n```html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n0.title: How to do lists in Vue\n1.author: Jane Doe\n2.publishedAt: 2016-04-10\n\n### 显示过滤/排序后的结果\n\n有时，我们想显示一个数组经过过滤或处理后的版本，而又不想实际变更或重置原始数据。这种情况，我们可以创建一个计算属性来返回过滤或处理后的数组\n\n例如：\n```html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n```js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n在计算属性不适应的情况下（例如 `v-for` 嵌套的情况下）可以使用方法\n\n```html\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n\n```\n```js \ndata: {\n  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n### 在 `v-for`里使用值范围\n\n`v-for` 也可以接受整数。这种情况，它会把模板重复对应次数。\n\n```html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n结果：\n\n1 2 3 4 5 6 7 8 9 10\n\n### `v-for` 与 `v-if` 一同使用\n\n注意：<a href=\"https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81\"> Vue 官方</a>不推荐二者在同一元素上使用\n\n当它们处于同一节点，`v-for`的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个`v-for`循环中。如果你想只为部分项渲染节点，这种优先级的机制十分有用。例如：\n```html\n    <li v-for=\"item in tasks\" v-if=\"!item.isComplete\">{{ item.taskName }}</li>\n```\n```js\ndata: {\n  tasks: [\n    {taskName: '测式11', isComplete: true},\n    {taskName: '测式2', isComplete: false},\n    {taskName: '测式3', isComplete: true},\n    {taskName: '测式4', isComplete: false},\n    {taskName: '测式5', isComplete: true}\n  ]\n}\n```\n结果：\n\n- 测速2\n- 测速4\n\n以上代码只渲染了 未完成的 taskName\n\n如果是有条件的跳过循环的执行，那么可以将`v-if`置于外层元素(或 `template`)\n\n```html\n<ul v-if=\"tasks.length\">\n  <li v-for=\"item in tasks\">\n    {{ item.taskName }}\n  </li>\n</ul>\n<p v-else>No taskName left!</p>\n```\n## 事件处理\n\n在内联语句处理器中访问原始的 DOM 事件。可以用特殊的变量 `$event` 把它传入方法：\n\n```html\n<button @click =\" test('hello', $event)\">Submit</button>\n\n```\n```js\nmethods: {\n  test: function (message, event) {\n    // 现在我们可以访问原生事件对象\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n### 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation` 是非常常见的需求。Vue 提供纯粹的数据逻辑，而不是去处理 DOM 事件。为解决这个问题 Vue 为 `v-on` 提供了事件修饰符。事件修饰符是由点的指令来表示的.\n\n- `.stop` 表示阻止冒泡事件\n- `.prevent` 表示阻止触发默认行为\n- `.capture` 表示使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理\n- `.self` 表示只当在 event.target 是当前元素自身时触发处理函数。只能自身由自身元素触发该事件。\n- `.once` 表示该事件仅触发一次\n- `.passive` 表示该事件不会阻止事件默认行为。可提高移动端运行效率。浏览器就无需监听事件是否会阻止默认行为。从而提高浏览器的运行效率\n\n### `.passive` 拓展\n关于 passive 的事件监听器，很久之前 addEventListener() 的参数约定是这样的：\n\n`addEventListener(type, listenerFunction, useCapture)`\n\n后来最后一个参数，也就是监听器是在捕获阶段执行还是冒泡阶段执行的 useCapture 参数变成了可选参数（传 true 的情况太少了）变成了：\n\n`addEventListener(type, listenerFunction[, useCapture])`\n\n而后又进行了修改，addEventListener() 的第三个参数可以是个对象值。\n\n```js\naddEventListener(type, listenerFuntion[, options])\n```\n目前 options 对象可用属性五个介绍较常用的三个：\n```js\naddEventListener(type, listener, {\n    capture: false,\n    passive: false,\n    once: false\n})\n```\n\n三个属性都是布尔型的开关，默认都为 false。其中 capture 属性等价于 之前的 useCapture 参数；once 属性表明监听器只一次之后就会被 removeEventListener 掉， passive 属性是本文的主角。\n\n很多移动端的页面都会监听 touchstart touch 事件，像这样：\n\n```js\ndocument.addEventListener(\"touchstart\", function(e){\n    ... // 浏览器不知道这里会不会有 e.preventDefault()\n})\n```\n由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。\n\n有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是“顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。\n下面是在 Chrome for Android 上滚动 cnn.com 页面的对比视频，右边在注册 touchstart 事件时添加了 {passive: true} 选项，左边没有，可以看到，右边的顺畅多了\n<video controls src=\"/video/passive 的事件监听器 - 紫云飞 - 博客园.mp4\"></video>\n\n假如在一个 passive 的监听器里执行了 preventDefault() 浏览器会发出警告并且会忽略 preventDefault()\n\n## 按键修饰符\n\n在监听事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：\n\n```html\n<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n```\n也可以 直接将 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values\">KeyboardEvent.key</a> 暴露的任意有效按键名来作为修饰符。例如：\n\n```\n<input v-on:keyup.page-down=\"onPageDown\">\n```\n### 按键码\n keyCode 的事件用法已经被废弃，并可能不最新的浏览器支持。\n```\n<input v-on:keyup.13=\"submit\">\n```\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获\"删除\"和\"退格\")\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n有一些按键（`.esc` 以及所有方向键）在 IE9 有不同的 `key` 值。如果想支持IE9。这些内置的别名是首选\n\n还可以通过全局 `config.keyCodes` 对象来自定义按键修饰符的别名\n\n```\n// 可以使用 `v-on:keyup.f1`\nVue.config.keyCodes.f1 = 112\n```\n\n### 系统修饰键\n\n- .ctrl\n- .alt\n- .shift\n- .meta (windows 系统上对应 Windows 徽标键 (⊞) )\n\n例如：\n\n```html\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n```\n**注意**系统按键修饰符和常规按键修饰符不同，在和 `keyup` 事件一起用时，事件触发时系统按键必须**处于按下状态**。也就是说，只有按住 `ctrl` 的情况下释放其他键，才能触发 `keyup.ctrl` 。而单单释放 `ctrl` 不会触发事件。而你如果想要 释放系统按键时触发事件那么请用 `keyup.ctrl` 换用 `keyup.17`\n\n### `.exact` 修饰符\n\n`.exact` 修饰符允许你控制由精确的系统修饰符组合才触发的事件\n\n```html\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n\n## 鼠标按钮修饰符\n\n- .left\n- .right\n- .middle\n\n这些修饰符会限制处理函数仅想要特定的鼠标按钮 例如\n\n```html\n<!-- 仅响应鼠标右键 -->\n<button @click.right=\"test1\">A</button>\n```\n\n## 表单输入绑定\n\n### 基本用法\n\n1. 可以使用`v-model` 双向绑定数据\n\n2. `v-model`在内部为不同的输入元素使用不同的 properyt 并抛出不同的事件\n\n- text (单行文本框) 和 txtarea (多单行文本框)元素使用 `value` property 和 `input`事件\n\n- checkbox(复选框) 和 radio(单选按钮) 使用 `checked` 和 `change`事件\n\n- select(下拉选择框) `value`作为property 和`change`作为事件\n\n#### 复选框\n\n单个复选框，绑定到布尔值\n\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n\n多个复选框，绑定到同一个数组：\n\n```html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<br>\n<span>Checked names: {{ checkedNames }}</span>\n```\n\n```\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n\n结果：\n\n- [X] Jack\n- [x] John\n- [x] Mike\n\nChecked names: [\"Jack\", \"John\", \"Mike\"]\n\n### 修饰符\n\n#### `.lazy`\n\n在默认情况下，`v-model` 在每次 `input` 事件触发将与数据同步，可以添加`lazy`修饰符，从而转为 `change`事件后进行同步\n\n```html\n<!-- 在“change”时而非“input”时更新 -->\n<input v-model.lazy=\"msg\">\n```\n\n#### `.number`\n\n如果想将用户的输入值自动转为数值类型，可以给 `v-model`添加 `.number` 修饰符，这通常是很有用，因为即使在 `type=\"number\"`时，HTML 输入元素也总会返回字符串\n\n#### `.trim`\n\n如果想要自动过滤用户输入的**首位空白**字符，可以给 `v-model` 添加 `trim` 修饰符\n\n```html\n<input v-model.trim=\"msg\">\n```\n\n## 组件基础\n\n在自定义事件也可以用于创建支持 `v-model`的自定义输入组件\n\n记住：\n```html\n<input v-model=\"seachText\">\n```\n\n等价于：\n\n```html\n<input \n\t:value=\"searchText\"\n\t@input=\"searchText = $event.target.value\"\n>\n```\n当用在组件上时，`v-model` 则会这样\n\n```html\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"$emit('input', $event.target.value)\"\n></custom-input>\n```\n为了让它正常工作，这个组件内必须这样写：\n- 将 `value` attribute 绑定到一个名叫 `value`的 prop 上\n- 在其`input`事件被触发时，将新值通过自定义的`input`事件抛出\n```js\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\n### 通过插槽分发内容\n\n和 HTML 元素一样，我们经常需要要向组件传递内容，像这样：\n\n```html\n<alert-box>\n  Something bad happened.\n</alert-box>\n```\nVue 自定义的 `<slot>` 元素让这个变的非常简单，插槽内可以包括任何模板代码包括HTML，甚至其他组件。\n\n```js\nVue.component('alert-box', {\n  template: \n  `\n    <div class=\"demo-alert-box\">\n      <strong>Error!</strong>\n      <slot></slot>\n    </div>\n  `\n```\n结果：\n\n**Error!**: Something bad happened.\n\n如果在 `alert-box` 的 `template` 中**没有** 包含一个 `<slot>元素，则组件起始标签和结束标签之前的任何内容都会被抛弃`\n\n### 编译作用域\n\n当想在一个插槽中使用数据，例如：\n\n```html\n<navigation-link url=\"/profile\">\n  Logged in as {{ user.name }}\n</navigation-link>\n```\n插槽跟模板的其他地方一样可以访问相同实例的 property 也就是相同作用域，但是不能访问 `navigation-link` 的作用域，例如 `url` 是访问不到的\n\n```\n<navigation-link url=\"/profile\">\n  Clicking here will send you to: {{ url }}\n  <!--\n  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是\n  _传递给_ <navigation-link> 的而不是\n  在 <navigation-link> 组件*内部*定义的。\n  -->\n</navigation-link>\n```\n作为一条规则，请记住：\n\n**父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的**\n\n### 后备内容\n\n有时为一个插槽设置具体的默认内容是很有用的，它只是会在没有提供内容的说话呗渲染。例如在 `<submit-button>`组件中：\n```html\n<button type=\"submit\">\n\t<slot></slot>\n</button>\n```\n我们可能希望这个 `<button>` 内绝大多数情况下都渲染文本 \"Submit\"，那么可以将它放入到 `<slot>` 标签内：\n\n```html\n<button type=\"submit\">\n\t<slot>Submit</slot>\n</button>\n```\n后背内容当没有提供插槽内容，那么后背内容将会显示。如果提供了插槽内容，那么显示提供的插槽内容。\n\n### 具名插槽\n\n有时我们需要多个插槽，例如对于一个带有如下模板的 `base-layout` 组件：\n\n```html\n<div>\n  <header>\n    <!-- 这里放页头 -->\n  </header>\n  <main>\n    <!-- 这里放主要内容 -->\n  </main>\n  <footer>\n    <!-- 这里放页脚 -->\n  </footer>\n</div>\n\n```\n对于这种情况，`solt` 元素有一个特殊的 attribute: `name`。这个 attribute 可以用来定义额外的插槽： \n\n```html\n<div>\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n一个不带 `name` 的 `slot` 出口会带有隐含的名字 `default`。\n\n在向具名插槽提供内容的时候，我们在`template`元素上使用 `v-slot`指令，并以 `v-solt` 的参数的形式提供名称：\n\n```html\n<base-layout>\n  <template v-slot:header>\n    <h1>这是页面的标题</h1>\n  </template>\n\n  <p>这是文章的主体内容</p>\n  <p>这是文章的主体内容111</p>\n    <!-- 也可以这样写 -->\n    <template v-slot:default>\n        主体内容\n    </template>\n  \n  <template v-slot:>\n    <p>这是页面的页脚</p>\n  </template>\n</base-layout>\n```\n以上的 `template` 元素中所有内容都将会被传入相应的插槽，任何没有被包裹 带有`v-slot`的 `template` 中的内容都会被视为默认插槽\n\n### 作用域插槽\n\n\n### v-solt\n\n在 2.6.0 中 具名插槽和作用域插槽引入了一个新的语法（`v-solt`）它取代了 `slot` 和 `slot-scope`","tags":["Vue相关","Vue基础知识"],"categories":["前端基础知识","Vue相关","Vue基础知识"]},{"title":"单词记录","url":"/2021/06/06/单词记录/","content":"| 单词   | 用途 | 备注|\n|-------|------|------|\n| prevent |修饰符使用`.prevent`修饰符来告诉`v-on`指令阻止默认事件，相当于调用`event.preventDefault()`| |\n| passive | 修饰符使用 `.passive` 修饰符事件不会调用preventDefault(),浏览器就无需监听此事件，从而提高运行效率 | |\n|computed|计算属性 | |\n|reverse|颠倒反转的意思，是数组中的将数组元素倒序的方法 | |\n| activated | Vue 的生命周期之一，被 keep-alive 缓存激活时调用 | |\n| destroy | Vue 的生命周期之一，实例被销毁时调用 | |\n","tags":["单词记录"],"categories":["学习日记","单词记录"]},{"title":"Vue生命周期钩子","url":"/2021/06/05/Vue生命周期钩子/","content":"\n## Vue生命周期钩子概述\n\n### 什么是生命周期？\n\n打比方 人类：从 出生 —> 童年 -> 青年 -> 老年 -> 死亡 从出生到死亡被称为人的生命周期。事物从出现到消失所经过几个里程碑的节点。程序亦是如此， Vue生命周期是指每个 Vue 实例被创建到销毁的过程。在这个过程中我们可以运行一些生命周期钩子的函数。\n\n### 生命周期钩子\n\n前言：\n1. 所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此可以使用 this.属性名访问 data 中数据\n2. 不能使用 箭头函数来定义生命周期方法因为箭头函数 `this` 绑定了父上下文。\n\n- 生命周期图\n\n![image-20210421161046575](/images/smzq.png)\n\n#### beforeCreate\n\n详细： 初始化事件和生命周期被调用\n\n#### created\n\n详细： 实例创建完成后立即被调用。这一步实例已经完成 property(对象属性)和方法的运算 watch/event事件回调完成。但是数据挂载阶段还未开始。\n\n应用场景: \n1. ajax 请求数据\n2. 页面初始化\n\n#### beforeMounted\n\n详细： 在数据挂载开始之前被调用：相关的`render` 函数首次被调用\n**该钩子在服务器渲染期间不被调用**\n\n### mounted\n\n详细: 实例被挂载之后调用,被创建的 DOM 已经更新。可以拿到 DOM 元素\n\n应用场景: \n1. ajax 请求数据\n2. 获取 Dom 元素\n\n### beforeUpdate\n\n详细：数据更新时被调用，这里适合在数据更新之前访问现有的 DOM 例如手动移除已添加的事件监听。\n\n### updated\n\n详细： 由于数据更改导致虚拟 DOM 重新渲染，在这之后会调用该钩子。当钩子被调用时，组件的 DOM 已经更新了，所以大多数情况都时用计算属性或 watch 取而代之。\n\n### activated\n\n详细： 被 keep-alive 缓存的组件激活时调用\n\n### deactivated\n\n详细： 被 keep-alive 缓存的组件停用时调用\n\n### beforeDestroy\n\n详细： 实例被销毁之前调用。在这一步，实例仍然可用\n\n### destroyed\n\n详细： 实例被销毁调用。在这一步，对应的 Vue 实例所有指令被解绑，所有事件监听被移除，子例也都被销毁\n\n### errorCaptured\n\n- 2.5.0+ 新增\n\n详细： 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播\n","tags":["Vue相关","Vue生命周期钩子"],"categories":["前端基础知识","Vue相关","Vue生命周期钩子"]},{"title":"前端不同单位的区别","url":"/2021/06/05/前端不同单位的区别/","content":"### 前端那些尺寸单位\n\n常见的尺寸单位： `px em rem % vw vh rpx` 下文总结下它们的用法\n\n## 一、px\n\n- 概述：\n\npx 像素就是 pixel 的缩写\npx 是指设备或图片中的最小的显示点，很多人认为 CSS 中的 px 是一个绝对单位，CSS 中设置 1px === 物理像素1点，实际这种说法是错误的。CSS中的 px 是一个相对的虚拟像素。因为不同设备的大小宽高相同时。它们的物理像素点是不同的。物理像素高的设备单位面积存放的像素点就高，画质也就很细腻。在 PC 端 px 接近实际的像素点大小，但在移动设备上，根据不同的机型分辨率大小，CSS 的一个 px 会对应不同数量的物理像素点\n\n- 特点：\n\n网页设计的常用单位，也是基本单位。用 px 单位固定设置布局或元素的大小，缺点：没有弹性、大小死板多端的页面无法做到适应的效果。\n\n## 二、%\n\n% 百分比单位\n%一般都是相对于父元素作为基础，例如子元素设置了 50% 指的是 子元素 === 父元素的*50% 也会有几种例外情况：\n- position: absolute // 相对已经定位的父元素\n- position: fixed // 相对于 ViewPort （视口）\n- transorm 2D水平移动变化是相对于自身\n\n## 三、vh\n\nvh CSS3 新单位 view height 的缩写\nvh 类似于 百分比单位，它相对于视窗，它将视窗高度分为100份，1vh 也就是占视窗的1%，举个例子 视窗高度 900px 如果设置 10vh 那么等于 90px\n\n## 四、vw\nvh CSS3 新单位 view width 的缩写\n和 vh 类似不同的是它只是相对于视窗宽度\n\n## 五、vm\n\nvm css3 新单位\n\nvm 也比较简单是指在视口中选取宽度或高度，选择其他最小的一个。然后和 vh 一样将其分为 100 份\n举例: 1200px宽 900px高度的视窗 10vm 就是 90px\n\n## 六、em\n\nem 相对字体大小来计算尺寸。它是相对字体大小的倍数。例如自身设置了 font-size:16px 那么 1em = 16、 10em = 160px。如果使用了 em 单位的元素自身设置字体大小那么相对于自身，如果自身没有设置那么查找父元素是设置。依次向上查找。如果都有没有射中那么使用浏览器默认字体大小 16px 为基准\n\n## 七、rem\n\nrem 和 em 基本类似，只是相对的对象不同。rem 只是会相对 html 根元素的字体大小。如果根元素设置了 字体大小为 20px 那么元素 设置 1rem === 20px\n\n补充：\n1. rem在制作响应式页面中经常使用到，因为我们可以根据不同的设备尺寸，去动态的调整根元素的大小，使用rem单位达到适配不同尺寸设备的效果，有些自适应的页面框架单位上的使用就是基于此种特性\n2. 有时我们为了换算方便会将根元素的字体大小先设置为62.5%，然后根据需要进行调整，原因是62.5%*16px = 10px，此时也就是1rem = 10px\n\n## 八、rpx\nrpx 响应式 px 单位\n由小程序最先提出的响应式px单位，为了解决px在移动端上不同的机型极容易出现的变形问题","tags":["前端基础知识","基础知识"],"categories":["前端基础知识","前端不同单位的区别"]},{"title":"鼠标拖动Div效果","url":"/2021/06/01/鼠标拖动Div效果/","content":"### 上效果图 \n\n![Animation](/images/sbtddiv.gif)\n\n### 本次 demo 用到一些属性\n\n`elment.clientWidth` 获取元素的宽度 包括自身的 `padding` 内容的宽度 不包括边框、返回值不带单位 \n`elment.clientHeight` 获取元素的高度 包括自身的 `padding` 内容的宽度 不包括边框、返回值不带单位 \n\n`element.offsetTop` elment 必须是相对定位的元素 该 API 返回 元素距离父元素上方的距离\n`element.offsetLeft` elment 必须是相对定位的元素 该 API 返回 元素距离父元素左方的距离\n\n- 在看的时候只要看懂一个就很好理解，因为它们是成对出现的\n- 为配合代码理解请看图 需要计算的值 为 4 = 3-(1-2) 这样就计算出来了 4 就是DIV距离父元素的偏移量\n\n![image-20210421161046575](/images/sbdtdiv.png)\n\n- 全部代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .div1 {\n      width: 500px;\n      height: 500px;\n      border: 1px solid red;\n      overflow: hidden;\n      position: relative;\n      margin: 0 auto;\n    }\n    .box {\n      width: 100px;\n      height: 100px;\n      background-color: red;\n      cursor: grab;\n      position: absolute;\n      user-select: none;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"box\">111</div>\n  </div>\n  <script>\n    // 大的DIV\n    let maxBox = document.querySelector('.div1')\n    // 拖动的DIV\n    let box = document.querySelector('.box')\n    // 鼠标是否按下\n    let flag = false\n    // 计算 拖动 div 的范围\n     let maxX = maxBox.clientWidth - box.clientWidth\n     let maxY = maxBox.clientHeight - box.clientHeight\n    //  鼠标按下时鼠标在页面中的位置\n    let ax = 0\n    let ay = 0\n    // 鼠标按下 div 在页面中的偏移量\n    let apx = 0\n    let apy = 0\n    // 鼠标按下\n    box.addEventListener('mousedown', (e)=> {\n      if (!flag) flag = true\n      box.style.cursor = 'grabbing'\n      // console.log(e)\n      ax = e.pageX\n      ay = e.pageY\n      apx = box.offsetLeft\n      apy = box.offsetTop\n    })\n    // 鼠标移动\n    box.addEventListener('mousemove', (e)=> {\n      if (flag) {\n        let offsetX = e.pageX - (ax - apx)\n        let offsetY = e.pageY - (ay - apy)\n        if (offsetX >= maxX || offsetX <= 0) return\n        if (offsetY >= maxY || offsetY <= 0) return\n        box.style.left = offsetX + 'px'\n        box.style.top = offsetY + 'px'\n      }\n    })\n    // 鼠标弹起\n    box.addEventListener('mouseup', ()=> {\n      if (flag) flag = false\n      box.style.cursor = 'grab'\n    })\n  </script>\n</body>\n</html>\n\n```","tags":["纯 JavaScript 小 Demo 练习"],"categories":["前端基础知识","纯 JavaScript 小 Demo 练习","鼠标拖动div的效果"]},{"title":"常用数组方法","url":"/2021/05/10/常用数组方法/","content":"## 常用的数组方法\n说明：\n1. 之前也发过一篇关于<a href=\"https://qingbohu.github.io/2021/05/04/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95/\">常见数组遍历方法的文章</a>，建议结合该篇一起食用效果最佳。\n2. 下面方法将会以是否会改变原数组分类\n### 改变原数组\n#### splice() 添加/删除数组元素\n作用：通过删除或替换新的元素来修改原数组，该方法会修改原数组的指。该方法返回值是被删除的元素组成的数组\n\n语法： `array.splice(start,[deleteCount,item1,item2...])`\n\n参数说明：\n\n- `start` ： 指定修改的位置（从0计数）如果是负数，则表示从数组末尾开始。\n- `deleteCount`：表示要移除的元素个数\n- `[item1,item2...]`：要添加的数组元素，如果不指定则只删除数组元素。\n\n实例\n\n```javascript\nvar array = [1, 2, 3, 4, 5, 6]\nvar arrayReturnedValue = array.splice(0, 2, 10, 20)\nconsole.log(arrayReturnedValue) // outPut: [1,2] 返回了被删除的元素组成的数组\nconsole.log(array) // outPut: [10, 20, 3, 4, 5, 6] 修改了原数组\n```\n#### pop() 删除数组中的最后一个元素\n\n作用： pop() 方法 将会删除数组中的最后一个元素，返回值是被删除的元素\n\n语法： `array.pop()`\n\n实例\n\n```javascript\nvar array = [1, 2, 3]\nconsole.log(array.pop()) // OutPut: 3  返回值是被删除的元素\nconsole.log(array) // OutPut: [1, 2]\n```\n#### shift() 删除数组中的第一个元素\n\n作用：shift() 方法删除数组中的第一个元素，返回值被删除的元素\n\n语法： `array.shift()`\n\n实例\n\n```javasctipt\nvar array = [3, 2, 1]\nconsole.log(array.shift()) // OutPut: 3 返回值被删除的元素\nconsole.log(array) // OutPut: [2, 1] \n```\n#### unshift() 在数组开头添加一个或多个元素\n\n语法： `array.unshift(element1[, element2....])`\n\n作用：unshift() 方法向数组的开头添加一个或多个元素，并返回数组添加后的长度\n\n```javascript\nvar array = [5, 6, 7]\nconsole.log(array.unshift(1, 2, 3, 4))// OutPut: 7\nconsole.log(array) // OutPut: [1, 2, 3, 4, 5, 6, 7]\n```\n\n#### reverse() 将数组倒序\n\n语法： `array.reverse()`\n\n作用：reverse() 方法可以将数组的顺序颠倒 返回值是被颠倒后的数组\n\n实例\n\n```javascript\nvar array = [1, 2, 3, 4, 5, 6]\nconsole.log(array.reverse())// OutPut:[6, 5, 4, 3, 2, 1]\nconsole.log(array)// OutPut:[6, 5, 4, 3, 2, 1]\n```\n---------------------------------------------------------------------华-丽-的-分-割-线--------------------------------------------------------------\n\n### 不改变原数组\n\n#### join() 将数组按照指定分隔符转成字符串\n\n作用：将 数组元素按照指定的分隔符转成字符串，默认是按照 逗号 分隔。\n\n语法： `array.join([*])`\n\n实例\n\n```javascript\nvar array  = ['hello', '您好']\nvar str = array.join() \nconsole.log(str) // hell,您好\nvar str1 = array.join('*')\nconsole.log(str1)// hell*您好\n```\n\n### toString() 将数组转成字符串 不推荐\n\n语法：`array.toString()`\n\n作用： 将数组转成以逗号分隔的字符串，因 toString 只能将数组转成以逗号分隔的字符串不能自定义所以不推荐使用，不如使用 `join()` 来转换。比起起使用 `toString()` 方法，当 数组 和 字符串相连接时数组会转成 以逗号分隔的字符串，这也是不推荐的使用 `toString()` 方法的原因之一。\n\n实例\n\n```javascript\nvar array = [1, 2, 3, '张三']\nconsole.log(array.toString()) // 1,2,3,张三\nconsole.log(array + '')// 1,2,3,张三\n\n```\n\n#### concat() 合并两个数组或多个\n\n作用： 方法合并两个或多个数组，并返回一个新的数组\n\n语法： `array.concat(array1[,array2,array3])`\n\n参数说明： array 和 array1....  代表要合并的数组\n\n实例\n\n```javascript\nvar array1 = [1, 2, 3]\nvar array2 = [3, 4, 5]\nvar array3 = ['六','七','八']\nvar newArray = array1.concat(array2, array3)\nconsole.log(newArray) // OutPut: [1, 2, 3, 3, 4, 5, \"六\", \"七\", \"八\"]\n```\n\n#### indexOf() 查找数组是否含有某元素\n\n作用： indexOf() 可以查找数组中是否含有某个元素，有：返回改元素在数组中的下标，无：返回 -1。 \n\n语法：`array.indexOf(element[,fromIndex])`\n\n参数说明： `element` 代表查找的元素 `fromIndex` 从哪个索引开始查找\n\n实例\n\n```javascript\narray.indexOf(elment, fromIndex)// 语法：element: 查找的元素 fromIndex: 从哪个索引开始查找\nvar array = ['张三', 18, '男']\nconsole.log(array.indexOf('女')) // OutPut： -1\nconsole.log(array.indexOf('男')) // OutPut： 2\nconsole.log(array.indexOf(18, 2))// OutPut -1 数组中有这个元素但是查找的索引是从 2 开始所以查找不到 返回 -1\n\n```\n\n#### lastIndexOf 查找数组是否包含某元素\n\n作用 ： 和 `indexOf` 作用一致用法一致，与之不同的是 lastIndexOf 是倒序查找元素。\n\n#### includes() 查找数组是否包含某元素 返回布尔\n\n作用： includes() 查找数组是否包含某元素 返回布尔\n\n语法：`array.includes(element)`\n\n参数说明： `element` 查找的元素\n\n实例\n\n```javascript\nvar array1 = [1, 2, 3, 4, 5]\nconsole.log(array1.includes(6))// outPut: false\nconsole.log(array1.includes(5))// outPut: true\n```\n#### slice()\n\n作用：浅拷贝数组。`slice()`方法返回一个新的数组对象，这个数组对象由 `start` 和 `end` 决定元素的浅拷贝 (包括 `satrt` 不包括 `end`)\n\n实例：\n\n```js\nconst array = ['ant', 'bison', 'camel', 'duck', 'elephant']\n\nconsole.log(array.slice(2))// ouPut:[\"camel\", \"duck\", \"elephant\"]\n\nconsole.log(animals.slice(2, 4));\n// expected output: Array [\"camel\", \"duck\"]\n```\n\n参数：\n`start`: 提取元素的起始索引，果如出现 `slice(-2)` 代表从数组的 倒数第二个元素开始提取\n\n`end`：提取元素的终止索引\n\n#### sort()\n\n作用：对数组元素进行排序，并返回数组。默认排序顺序是将元素转为字符串然后比较它们的UTF-16代码单元值\n\n实例 ：\n```js\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\nconsole.log(months);\n// expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n// expected output: Array [1, 100000, 21, 30, 4]\n\n```\n语法： `arr.sort([compareFunction])`\n\n参数：\n1. `compareFunction`： 可选参数 用来指定按照某种顺序进行排列的函数，如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。\n1.1 `firstEl`: 第一个比较的元素\n1.2 `secondEl`: 第二个比较的元素\n\n返回值：排序后的数组，已经原地排序了。改变了原数组。\n\n描述：\n如果指明了 `compareFunction()`,那么数组会按照调用该函数的返回值排序。\n- 如果要比较的是数字而非字符串 `compareFunction(a, b) {return a - b}` 函数会对数组进行升序 \n常用例子：\n```js\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);\n\n也可以写成：\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n也可以按照某个属性进行排序\n```js\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\n// sort by value\nitems.sort(function (a, b) {\n  return (a.value - b.value)\n});\n\n// sort by name\nitems.sort(function(a, b) {\n  var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n  var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n  if (nameA < nameB) {\n    return -1;\n  }\n  if (nameA > nameB) {\n    return 1;\n  }\n\n  // names must be equal\n  return 0;\n});\n```\n\n#### flat()\n\n作用： 自定义深度遍历数组并返回，并将所有元素与遍历到的子数组合并成为一个新数组返回。\n\n语法： `array.flat([depath])`\n\n参数：\n\ndepath 可选参数，指定提取嵌套数组的结构深度，默认值为 1 \n\n返回值： 一个包含数组与子数组的新数组\n\n实例：\n```js\nvar array = [1, 2, 3, [4, 5,[6, 7]]]\nconsole.log(array.flat(2)) // outPut:[1, 2, 3, 4, 5, 6, 7]\n```","tags":["基础知识","数组方法"],"categories":["前端基础知识","数组相关操作"]},{"title":"无须联网激活系统工具","url":"/2021/05/07/无须联网激活系统工具/","content":"### 软件介绍\nHEU KMS Activator 是一位叫 知彼而知己 的大神所开发的KMS激活工具，最新版本新增加了OEM激活，增加对Vista/Win7/Server 2008 (R2)/2012 (R2) OEM的永久激活(支持Legacy/UEFI BIOS)，此工具可以完美的激活Windows以及Office的VL版本，无需联网即可一键激活，目前最新版的HEU KMS Activator 新增Win10数字许可证激活，不在是以前的那个KMS激活了，很多系统都可以使用数字权利永久激活使用，而且此工具带有静默激活参数可以用来封装使用，在封装系统安装后调用HEU KMS Activator 计划任务 加上静默激活参数可完美激活，此版本激活成功率最高，推荐系统封装爱好者使用，此工具由亿破姐收集整理100%出自“知彼而知己”的正版，无广告，无流氓行为，无捆绑，无后门的激活工具。\n### 下载地址\nhttps://wwr.lanzoui.com/i9ilBowio2f\n密码:gbtz","tags":["工具分享"],"categories":["工具分享","激活软件","Windows无须联网激活工具"]},{"title":"网站使用介绍","url":"/2021/05/06/网站使用介绍/","content":"## 前言\n非常幸运能得到您的访问，希望我的博客能给您带来帮助。在博客我主要分享自己在学习路上所遇到的坎坷、学习笔记分享、常用的工具分享、生活日记等。如果您在使用过程遇到问题或文章中出现错误，欢迎您给你提出宝贵的意见。\n\n\n## 网站使用说明\n\n1. 网站使用 hexo 框架搭建的部署在 github 中\n\n2. 如何查找文章？\n- 点击网站右上角搜索可以对文章进行检索\n![image-20210421161046575](/images/sysm.png)\n3. 首页文章太杂乱了。找不到我想看的类型？\n- 点击网站导航中的 __文章分类__ 可以对文章进行分类查看\n![image-20210421161046575](/images/wzfl.png)\n\n","tags":["网站使用介绍"],"categories":["网站使用介绍"]},{"title":"XMind脑图软件","url":"/2021/05/06/XMind脑图软件/","content":"## 软件介绍\n我经常拿这个软件来记笔记，非常不错的软件，分享给大家。XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。XMind ZEN具有强大的绘图基础，除了常规的组织结构图、逻辑图、鱼骨图、矩阵图之外，还可以发挥自己的想象力，通过简单的自由主题和主题间的联系，打破思维导图的固有模式，画出极具创意的结构模式。\n## 下载地址\n蓝奏云：\nhttps://wwr.lanzous.com/b0263xa3i\n密码:e0kf","tags":["工具分享"],"categories":["工具分享","办公软件","XMind思维导图软件"]},{"title":"Office系列软件","url":"/2021/05/06/office系列软件/","content":"### 应用介绍\noffice 2019 \n### 下载地址\n链接: https://pan.baidu.com/s/159n4RyG7SGumNvhtCf0fqA 提取码: 4iry 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","办公软件","Office 全系列软件"]},{"title":"adobe系列软件","url":"/2021/05/06/adobe系列软件/","content":"### 应用介绍\n软件内涵盖所有欧特比系列的全新软件，并贴心的分为大师版光盘镜像和独立版软件，将可独立安装的SP版和体积较大的大师版都打包了进去。所有产品都免激活，集破解补丁于一体，一键安装即可使用，无需复杂的操作，支持自定义选择简体中文、安装路径设置，十分方便。需要注意的是软件因配置需求因素，需要安装在最新的最新的Windows 10系统上面，并需要配置高性能硬盘，并保存足够的剩余空间。小编分享的赢政天下Adobe2021大师版，有专业需求的不妨下载收藏。\n### 下载地址\n链接: https://pan.baidu.com/s/1z4gnkfRA5bMClg-DsKmc5g 提取码: siy7 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","制图工具","Adobe2020全系列软件"]},{"title":"深入理解原型链与继承","url":"/2021/05/06/深入理解原型链与继承/","content":"## 构造函数、原型对象、实例三者之间的关系\n- 构造函数  =\\=\\=\\= prototype=\\=\\=\\=>  原型对象\n- 原型对象 =\\=\\=\\=constructor =\\=\\=\\=> 构造函数\n- 实例 =\\=\\=\\= \\_\\_proto\\_\\_ =\\=\\=\\=> 原型对象 \n\n借助一张图来理解：\n![image-20210421161046575](/images/yxl.png)\n\n## 重写原型对象\n应用场景：在实现某一功能时，经常会用一个包含所有属性和方法重写整个原型对象。（因为添加的方法或属性很少那么只需要在原型对象上添加。其实在工作中更多的是在原型对象的基础上添加属性或方法，而不重写整个原型对象）\n\n重写整个原型对象：\n```javascript\nPerson.prototype = {\n    name: \"神奇的程序员\",\n    age: \"20\",\n    job: \"web前端开发\",\n    sayName: function () {\n        console.log(this.name);\n    }\n    constructor: Person\n}\n```\n\n在原型对象上添加属性或方法\n```javascript\nPerson.protutypt.name = \"神奇的程序员\"\nPerson.protutypt.age = \"20\"\nPerson.protutypt.sayName = function(){\n\tconsole.log(this.name)\n}\n\n```\n- 两种方法作用其实是一样的。重写整个原型对象如果不手动设置 constructor 属性那么它的 constructor 属性会指向 Object （正常情况应该指向对应的构造函数）\n\n## 原型链\n\n1. 当访问一个对象的成员(属性或方法),首先查找这个对象自身有没有该成员\n2. 在该对象中没有查找该成员,查找在它的原型对象是否有该成员(\\_\\_prototype\\_\\_指向原型对象)\n3. 原型对象上没有查找该成员,在 Object 的原型对象查找\n4. 还是没有找到 返回 Null\n- 以上四部构成了原型链,只要在任意一层找到了就执行该成员,没有都找到返回 Null\n\n## 原型对象继承\n\n- 每个构造函数都有一个原型对象\n- 原型对象都有 constructor 属性它是指向构造函数（被重写原型对象除外，没有手动指回原型对象的，默认指向 Object ）\n- 每个构造函数通过 prototype指向原型对象\n\n原型链继承就是一个构造函数原型对象等于另一个构造函数的实例，此时的原型对象将包含一个指向另一个构造函数原型的指针。下面的例子 Sub 构造函数 的原型对象重写成了 Super 实例。Sub 可以调用调用 Super 的原型对象上的方法，这就组成了一条原型链。 \n\n```javascript\nfunction Super() {\n  this.superStatus = true\n}\n// 在原型对象上添加方法\nSuper.prototype.getSuperStatus = function() {\n  return this.superStatus\n}\nfunction Sub() {\n  this.subStatus = false\n}\n// 在原型对象上添加方法\nSub.prototype.getSubStatus = function() {\n  return this.subStatus\n}\n// 将 Sub 原型对象指向 Super 实例 此时constructor 被重写 指向 Super\nSub.prototype = new Super()\n\n// 实例化 Sub\nvar sub = new Sub()\n// sub 实例没有 getSuperStatus 方法 但是因为我们之前它的原型对象重写指向了 Super \nconsole.log('获取Super的属性值',sub.getSuperStatus()) // outPut: 获取Super的属性值 true\n```\n### 原型链继承存在的问题\nSub 的原型对象重写成 Super 的实例，Sub 继承 Super 的全部属性和方法。我们需求是在 实例 sub1 上添加的数据，但是后面的 sub2 也受到了影响。这就是存在的问题。\n```javascript\nfunction Super() {\n  this.list = [\"a\",\"b\",\"c\"];\n}\n\nfunction Sub() {\n\n}\nSub.prototype = new Super();\nconst sub1 = new Sub();\nsub1.list.push(\"d\");\nconsole.log(sub1.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\nconst sub2 = new Sub();\nconsole.log(sub2.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\n```\n## 类\n\n在 ES6 之前 JavaScript 是没有类的概念，都是用 构造函数来代替类的作用。类的出现极大的简化操作，\n### 类的语法\n\n- 创建类\n```javascript\n// 创建类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\t// 类的方法\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\nf1 = new Fathe('张三', 20)\nconsole.log(f1.name, f1.age) // outPut: 张三 20\n```\n### 类的继承\n\n构造函数和类的作用都用来实例化对象的。使对象之间有关联性，而类的优点在于更加方便的创建继承，不需要想构造函数那样使用 寄生式继承、修改原型对象指向继承、构造函数静态方法继承。但是 类的底层实现方法还是基于构造函数的方法。\n\n实例\n\n```javascript\n// 创建父类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\n// 创建子类 使用 extends 继承父类 \nclass Children extends Fathe {\n  constructor(name,age, sex) {\n    // 继承父类的 ane age 属性 \n      // super 要写 this 最前面\n    super(name, age) \n    this.sex = sex\n  }\n}\n\nvar children1 = new Children('李四', 20, '男')\nchildren1.say()  // 子类调用父类的方法\nconsole.log(children1) \n```\n\n\n\n\n\n\n","tags":["原型链与继承"],"categories":["前端基础知识","原型链与继承"]},{"title":"常见数组遍历方法","url":"/2021/05/04/数组遍历相关的方法/","content":"- 说明：\n1. 书写顺序按实际工作中使用的频率排序。\n2. 参数中出现 [] (中括号) 表示在为可选参数\n3. 建议和<a href=\"https://qingbohu.github.io/2021/05/10/%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/\" >常用数组方法</a>该篇一起食用效果更佳\n\n# 常见的数组遍历方法\n## forEach 方法\nforEach 是最常见的数组遍历方法，使用简单功能单一。就是遍历数组的每一个元素\n### 语法\n全部参数：\n```javascript\narray.forEach(callback(current[, currentIndex, currentArray]){\n  console.log(current)\n}[, thisArg])\n```\n精简参数\n```javascript\narray.forEach(callback(current){\n  console.log(current)\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`forEach` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = ['张三', '李四', '王五']\narray.forEach((current, currentIndex, currentArray)=>{\n    console.log('当前被遍历的元素为：',current)\n    console.log('当前被遍历的元素下标为：',currentIndex)\n    console.log('当前被遍历的元素的数组对象：',currentArray)\n    console.log('回调函数中的this指向为：',this)\n    console.log('-----------------------------')\n},window)\n```\n--------------------------------------------------------------------------------------------------\n## find 和 findIndex 方法\n1. find 方法可以查找数组中第一个符合条件的元素 返回值：查找到的元素。\n2. findeIndex 方法可以查找数组中第一个符合条件的元素  返回值： 符合条件的元素下标\n- 需要注意的是 find 和 findIndex 当查找到符合条件的元素，就会结束查找，所以它只会查找到第一个符合条件的元素，另外它们两个的用法是一样的，只是返回值不一致。\n### 语法\n因为 finde 和 findeIndex 方法用法是一样的那么只演示其中一个\n```javascript\narray.find((current[, currentIndex, currentArray]) => {\n\treturn current > 10 // 条件\n}[,thisAry])\n```\n### 参数说明\nfind 一个接受两个参数 `callback` 和 `thisAry`\n1. `callback` 查找元素是执行的回调函数 注意需要将条件 return\n- `current`: 当前执行回调的元素 \n- `currentIndex`[可选]: 当前执行回调元素的下标\n- `currentArray`[可选]: 当前按执行回调元素的数组\n2. `thisAry`[可选] ： 执行回调函数时的 this 指向\n\n### 实例\n```javascript\nvar array = [7, 8, 20, 40, 50, 60]\nvar result1 = array.find((current) => {\n\treturn current === 20\n})\nvar result2 = array.findIndex((current) => {\n\treturn current === 20\n})\nconsole.log(result1) // outPut: 20 \nconsole.log(result2) // outPut: 2 \n```\n## map 方法\nmap 方法可以用数组元素的映射，该方法不会改变源数组的值返回一个新的数组，参数和 forEach 函数是一样的。区别：因为 map 方法会返回一个全新的数组，那么在回调函数要使用 return 将当前元素返回。 \n### 语法\n全部参数：\n```javascript\narray.map(callback(current[, currentIndex, currentArray]){\n  return current + 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.map(callback(current){\n  return current + 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`map` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\n// 将原来的数组每个元素 + 10 返回\nvar array = [1, 2, 3, 4]\nvar result = array.map((current)=>{\n    return current + 10\n})\nconsole.log(result) // outPut: [11, 12, 13, 14]\n```\n--------------------------------------------------------------------------------------------------\n## filter 方法\nfilter 方法是对数组元素进行筛选，将符合条件的元素返回成一个数组 和 map 方法 用法差不多 都需要 return 它们作用不同\n### 语法\n全部参数：\n```javascript\narray.filter(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.filter(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`filter` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.filter((current)=>{\n    return current > 30\n})\nconsole.log(result) // outPUt: [33, 78, 60]\n```\n---------------------------------------------------------------------------------------------------------\n## some 方法\nsome 方法 测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值, 有无元素符合条件 有:返回 ture 无:返回flase\n### 语法\n全部参数：\n```javascript\narray.some(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.some(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`some` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.some((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: true\n```\n------------------------------------------------------------------------------------------------------\n## every 方法\nevery 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n### 语法\n全部参数：\n```javascript\narray.every(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.every(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`every` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.every((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: false\n```\n## reduce 方法\nreduce 方法虽然不常见但是用起来是最爽的一个，应用场景也非常多。例如 数组去重、统计字符出现的次数、扁平化数组。一般用于本次循环结果和下次循环结果有关联的场景。\n### 语法\n全部参数：\n```javascript\narray.reduce((total, current, currentIndex, currentArray) => {\n  return current \n},init)\n\n```\n精简参数：\n```javascript\narray.reduce((total, current) => {\n  return total \n})\n```\n`reduce` 一共接收两个参数 \n1. callback 每个元素执行的回调函数\n- total 累积器\n- current 当前元素\n- currentIndex 当前元素的下标\n- currentArray 当前元素的数组对象\n2. init 第一次执行回调函数时的初始值\n### 实例\n#### 一、数组去重\n```javascript\nvar array = [1, 1, 2, 2, 5, 5, 7, 7, 10, 10]\nvar result = array.reduce((total, current) => {\n    if (!total.includes(current)){\n        total.push(current)\n    }\n    return total\n},[])\nconsole.log(result) // outPut: [1, 2, 5, 7, 10]\n```\n#### 二、统计字符出现的次数\n```javascript\nvar str = 'asdihfsahf;shagfiohsagohsfjsdhfiusgfigasd'\nvar array = str.split('')\nvar result = array.reduce((total, current)=>{\n  if (total[current]) {\n    total[current]++\n  }else{\n    total[current] = 1\n  }\n  return total\n},{})\nconsole.log(result) // outPut: {a: 5, s: 8, d: 3, i: 4, h: 6, …} \n```","tags":["基础知识","数组遍历"],"categories":["前端基础知识","数组相关操作"]},{"title":"关于我","url":"/2021/05/01/关于我/","content":"### 首先非常感谢您阅读我的文章，世界之大能让您能看到我荣幸之至。\n### 个人标签：\n男、九九后、处女座、较真、正直、强迫症\n### 爱好：\n篮球、游戏、爬山、逛大佬博客网站、听前辈讲故事、用技术解决问题\n### 个人简介\n  目前在职 Web前端开发，真的十分庆幸能在自己喜欢的工作岗位上工作。首先感谢我的爸妈，这么多年对我的培养，虽然他们知识文化不高但是却给了我很好的生活和选择的权力，其次感恩老师，在叛逆期是老师的孜孜不倦的教诲才让我没有走错路，当很多人放弃了你却还有那么一个老师对你另眼相看给了你信心。在技术路上对我提供帮助的老师，通过你们的课程让我对技术有很多认识。\n\n  关于我：我一个非常简单的人，正如一个 API 你对我的输入，我也将会输出。性格开朗活泼，对技术充满向往和好奇。路漫漫其修远兮，吾将上下而求索。\n","tags":["关于我"],"categories":["生活日记"]}]