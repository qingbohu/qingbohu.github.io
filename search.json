[{"title":"JS实用小技巧","url":"/2021/06/07/JS实用小技巧/","content":"## 1. 立即执行函数\n一般在做业务的时候，都会有一个入口函数。例如\n\n```js\nfunction init(){\n    //...\n}\ninit()\n```\n其实可写成这种形式\n\n```js\n(function init(){\n    //...\n})()\n```\n好处：1. 拥有独立作用域 2.init函数没有必要再全局作用域下展示\n\n## 2. 变量类型转化\n\n在写代码时常会进行变量类型的转化 `parseInt()` `parseFloat()` 和 `toString()` 方法转化变量类型\n\n```js\nvar str = '10.9'\nconsole.log(typeof (parseFloat(str))) // outPut: number\nvar number = 66\nconsole.log(typeof (toString(number))) // outPut: string\n```\n其实也可以这么写，不仅容易记忆而且减少了代码量\n```js\nvar str = '10.9'\nconsole.log(typeof (str - 0)) // outPut: number\nvar number = 66\nconsole.log(typeof (number + '')) // outPut: string\n```\n\n## 3.短路操作\n\n没学会短路操作之前的代码\n\n```js\nif (!foo) {\n  foo = bar \n}\n\n```\n短路操作\n```js\nfoo = foo || bar \n```\n好处: 1. 代码量减少 2. 书写优雅\n\n短路原理记忆方法：\n在 JS 中 `&&` 和 `||` 都有一个共同的特性。\n `&&` 前后两个表达式，前为 false 后者不执行。 \n`||`前后两个表达式, 前为 true 后者不执行。\n\n## 4. 三元表达式\n\n三元表达式在每门语言中都会用到，没学之前会这么写\n\n```js\nif( a === true ) {\n  b = c\n} else {\n  b = d\n}\n```\n\n三元表达式可以这么写\n\n```js\nlet b = a ? c : d\n\n```\n\n优点： 1. 减少代码量 2. 优雅","tags":["前端基础知识","JS基础"],"categories":["前端基础知识","JS基础","JS小技巧"]},{"title":"vue基础知识","url":"/2021/06/06/vue基础知识/","content":"\n## 计算属性\n\n概述： 计算属性的出现是为了解决模板的简单运算，在模板中放入天多的逻辑会让模板难以维护例如：\n\n```html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\n在这个地方模板不在是简单的输出内容或声名逻辑，这里要显示变量`message`的翻转字符串。这样的写法后期很难维护。所以我们要将它写入到 **计算属性**中\n\n例子：\n```html\n<div id=\"example\">\n  <p>原始的 message: \"{{ message }}\"</p>\n  <p>计算后倒叙 message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n```js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\n结果：\n```\n原始的 message: \"Hello\"\n\n计算后倒叙 message: \"olleH\"\n```\n注意点： computed(计算属性) 和 methods 可以实现相同功能，computed 和 methods 还是有区别，computed 计算一次会有缓存，如果被计算的属性值没有发生变化。computed 中的函数不会再执行计算，而是将缓存的结果返回。这样提高效率。而 methods 无论数值是否发生变化都会触发一次。 如果不希望有缓存可以用方法来代替。\n\n### 计算属性的 setter\n\n计算属性默认只有 getter，不过再需要时也可以提供一个 setter。\n\n什么是 getter 和 setter ？\n\n在我的理解 getter 是一个输出，将属性按照规则输出。setter 是一个输入。当手动改变了输出的值 setter 被触发。\n\n例子：\n\n```js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n\n```\n现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新\n\n## 侦听属性\n\n侦听属性 `watch` 当有些数据需要随着其他数据变动而变动时，很容易滥用 `watch`。例如\n\n```html\n<div id=\"demo\">{{ fullName }}</div>\n```\n```js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n上述代码重复。计算属性，中的变量只要任何一个发生变化，就会重新计算值。监听与计算属性的进行比较：更适合\n\n```js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\n## Class 与 Style 的绑定\n\n### 对象语法\n\n可以传给 `v-bind:class` 一个对象，这样可以动态的切换 class：\n```html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n上面语法表示 `active` 这个 class 是否存在取决于数据 property `isActive` 布尔值。\n\n也可以在对象中传入多个字段来切换 多个class。此外 `v-bind:class` 指令也可以与普通的 class attribute 共存。\n\n```html\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n```js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n渲染结果为：\n```html\n<div class=\"static active\"></div>\n```\n绑定的数据对象不必内联定义在模块中，也可以写在`data` 中方便后期维护\n\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n```js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\n绑定的对象也可以是计算属性。\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n```js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n### 数组语法\n\n也可以把数组传给 `v-bind:class`\n```html\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n```\n```js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n渲染的结果为\n```\n<div class=\"active text-danger\"></div>\n```\n根据条件切换class，也可以用三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n数组中也可以使用对象语法。只有在 isActive 是 true 是才会添加 active 类 而 errorClass 始终存在\n```html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n## 列表渲染\n\n使用 `v-for`指令基于一个数组要渲染一个列表。`v-for` 还支持可选的第二个参数，时当前项的索引。\n```html\n<ul id=\"example-1\">\n  <li v-for=\"(item, index) in items\" :key=\"item.message\">\n    {{ item.message }} -- {{ index }}\n  </li>\n</ul>\n```\n```js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n结果\n- Foo\n- Bar\n\n也可以使用 `of` 代替 `in` 操作符 因为它更接近 JS 迭代器\n\n### `v-for` 里使用对象\n\n可以用 `v-for` 来遍历一个对象的\n\n```html\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n```js\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n```\n结果：\n- How to do lists in Vue\n- Jane Doe\n- 2016-04-10\n\n也可以提供第二个参数（也就是键名）：\n\n```html\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n```\n结果：\ntitle: How to do lists in Vue\nauthor: Jane Doe\npublishedAt: 2016-04-10\n\n还可以用第三个参数作为索引\n```html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n0.title: How to do lists in Vue\n1.author: Jane Doe\n2.publishedAt: 2016-04-10\n\n### 显示过滤/排序后的结果\n\n有时，我们想显示一个数组经过过滤或处理后的版本，而又不想实际变更或重置原始数据。这种情况，我们可以创建一个计算属性来返回过滤或处理后的数组\n\n例如：\n```html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n```js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n在计算属性不适应的情况下（例如 `v-for` 嵌套的情况下）可以使用方法\n\n```html\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n\n```\n```js \ndata: {\n  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n### 在 `v-for`里使用值范围\n\n`v-for` 也可以接受整数。这种情况，它会把模板重复对应次数。\n\n```html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n结果：\n\n1 2 3 4 5 6 7 8 9 10\n\n### `v-for` 与 `v-if` 一同使用\n\n注意：<a href=\"https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81\"> Vue 官方</a>不推荐二者在同一元素上使用\n\n当它们处于同一节点，`v-for`的优先级比 `v-if` 更高，这意味着 `v-if` 将分别重复运行于每个`v-for`循环中。如果你想只为部分项渲染节点，这种优先级的机制十分有用。例如：\n```html\n    <li v-for=\"item in tasks\" v-if=\"!item.isComplete\">{{ item.taskName }}</li>\n```\n```js\ndata: {\n  tasks: [\n    {taskName: '测式11', isComplete: true},\n    {taskName: '测式2', isComplete: false},\n    {taskName: '测式3', isComplete: true},\n    {taskName: '测式4', isComplete: false},\n    {taskName: '测式5', isComplete: true}\n  ]\n}\n```\n结果：\n\n- 测速2\n- 测速4\n\n以上代码只渲染了 未完成的 taskName\n\n如果是有条件的跳过循环的执行，那么可以将`v-if`置于外层元素(或 `template`)\n\n```html\n<ul v-if=\"tasks.length\">\n  <li v-for=\"item in tasks\">\n    {{ item.taskName }}\n  </li>\n</ul>\n<p v-else>No taskName left!</p>\n```\n## 事件处理\n\n在内联语句处理器中访问原始的 DOM 事件。可以用特殊的变量 `$event` 把它传入方法：\n\n```html\n<button @click =\" test('hello', $event)\">Submit</button>\n\n```\n```js\nmethods: {\n  test: function (message, event) {\n    // 现在我们可以访问原生事件对象\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n### 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation` 是非常常见的需求。Vue 提供纯粹的数据逻辑，而不是去处理 DOM 事件。为解决这个问题 Vue 为 `v-on` 提供了事件修饰符。事件修饰符是由点的指令来表示的.\n\n- `.stop` 表示阻止冒泡事件\n- `.prevent` 表示阻止触发默认行为\n- `.capture` 表示使用事件捕获模式 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理\n- `.self` 表示只当在 event.target 是当前元素自身时触发处理函数。只能自身由自身元素触发该事件。\n- `.once` 表示该事件仅触发一次\n- `.passive` 表示该事件不会阻止事件默认行为。可提高移动端运行效率。浏览器就无需监听事件是否会阻止默认行为。从而提高浏览器的运行效率\n\n### `.passive` 拓展\n关于 passive 的事件监听器，很久之前 addEventListener() 的参数约定是这样的：\n\n`addEventListener(type, listenerFunction, useCapture)`\n\n后来最后一个参数，也就是监听器是在捕获阶段执行还是冒泡阶段执行的 useCapture 参数变成了可选参数（传 true 的情况太少了）变成了：\n\n`addEventListener(type, listenerFunction[, useCapture])`\n\n而后又进行了修改，addEventListener() 的第三个参数可以是个对象值。\n\n```js\naddEventListener(type, listenerFuntion[, options])\n```\n目前 options 对象可用属性五个介绍较常用的三个：\n```js\naddEventListener(type, listener, {\n    capture: false,\n    passive: false,\n    once: false\n})\n```\n\n三个属性都是布尔型的开关，默认都为 false。其中 capture 属性等价于 之前的 useCapture 参数；once 属性表明监听器只一次之后就会被 removeEventListener 掉， passive 属性是本文的主角。\n\n很多移动端的页面都会监听 touchstart touch 事件，像这样：\n\n```js\ndocument.addEventListener(\"touchstart\", function(e){\n    ... // 浏览器不知道这里会不会有 e.preventDefault()\n})\n```\n由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。\n\n有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是“顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。\n下面是在 Chrome for Android 上滚动 cnn.com 页面的对比视频，右边在注册 touchstart 事件时添加了 {passive: true} 选项，左边没有，可以看到，右边的顺畅多了\n<video controls src=\"/video/passive 的事件监听器 - 紫云飞 - 博客园.mp4\"></video>\n\n假如在一个 passive 的监听器里执行了 preventDefault() 浏览器会发出警告并且会忽略 preventDefault()","tags":["Vue相关","Vue基础知识"],"categories":["前端基础知识","Vue相关","Vue基础知识"]},{"title":"单词记录","url":"/2021/06/06/单词记录/","content":"| 单词   | 用途 | 备注|\n|-------|------|------|\n| prevent |修饰符使用`.prevent`修饰符来告诉`v-on`指令阻止默认事件，相当于调用`event.preventDefault()`| |\n| passive | 修饰符使用 `.passive` 修饰符事件不会调用preventDefault(),浏览器就无需监听此事件，从而提高运行效率 | |\n|computed|计算属性 | |\n|reverse|颠倒反转的意思，是数组中的将数组元素倒序的方法 | |\n| activated | Vue 的生命周期之一，被 keep-alive 缓存激活时调用 | |\n| destroy | Vue 的生命周期之一，实例被销毁时调用 | |\n","tags":["单词记录"],"categories":["学习日记","单词记录"]},{"title":"Vue生命周期钩子","url":"/2021/06/05/Vue生命周期钩子/","content":"\n## Vue生命周期钩子概述\n\n### 什么是生命周期？\n\n打比方 人类：从 出生 —> 童年 -> 青年 -> 老年 -> 死亡 从出生到死亡被称为人的生命周期。事物从出现到消失所经过几个里程碑的节点。程序亦是如此， Vue生命周期是指每个 Vue 实例被创建到销毁的过程。在这个过程中我们可以运行一些生命周期钩子的函数。\n\n### 生命周期钩子\n\n前言：\n1. 所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此可以使用 this.属性名访问 data 中数据\n2. 不能使用 箭头函数来定义生命周期方法因为箭头函数 `this` 绑定了父上下文。\n\n- 生命周期图\n\n![image-20210421161046575](/images/smzq.png)\n\n#### beforeCreate\n\n详细： 初始化事件和生命周期被调用\n\n#### created\n\n详细： 实例创建完成后立即被调用。这一步实例已经完成 property(对象属性)和方法的运算 watch/event事件回调完成。但是数据挂载阶段还未开始。\n\n应用场景: \n1. ajax 请求数据\n2. 页面初始化\n\n#### beforeMounted\n\n详细： 在数据挂载开始之前被调用：相关的`render` 函数首次被调用\n**该钩子在服务器渲染期间不被调用**\n\n### mounted\n\n详细: 实例被挂载之后调用,被创建的 DOM 已经更新。可以拿到 DOM 元素\n\n应用场景: \n1. ajax 请求数据\n2. 获取 Dom 元素\n\n### beforeUpdate\n\n详细：数据更新时被调用，这里适合在数据更新之前访问现有的 DOM 例如手动移除已添加的事件监听。\n\n### updated\n\n详细： 由于数据更改导致虚拟 DOM 重新渲染，在这之后会调用该钩子。当钩子被调用时，组件的 DOM 已经更新了，所以大多数情况都时用计算属性或 watch 取而代之。\n\n### activated\n\n详细： 被 keep-alive 缓存的组件激活时调用\n\n### deactivated\n\n详细： 被 keep-alive 缓存的组件停用时调用\n\n### beforeDestroy\n\n详细： 实例被销毁之前调用。在这一步，实例仍然可用\n\n### destroyed\n\n详细： 实例被销毁调用。在这一步，对应的 Vue 实例所有指令被解绑，所有事件监听被移除，子例也都被销毁\n\n### errorCaptured\n\n- 2.5.0+ 新增\n\n详细： 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播\n","tags":["Vue相关","Vue生命周期钩子"],"categories":["前端基础知识","Vue相关","Vue生命周期钩子"]},{"title":"前端不同单位的区别","url":"/2021/06/05/前端不同单位的区别/","content":"### 前端那些尺寸单位\n\n常见的尺寸单位： `px em rem % vw vh rpx` 下文总结下它们的用法\n\n## 一、px\n\n- 概述：\n\npx 像素就是 pixel 的缩写\npx 是指设备或图片中的最小的显示点，很多人认为 CSS 中的 px 是一个绝对单位，CSS 中设置 1px === 物理像素1点，实际这种说法是错误的。CSS中的 px 是一个相对的虚拟像素。因为不同设备的大小宽高相同时。它们的物理像素点是不同的。物理像素高的设备单位面积存放的像素点就高，画质也就很细腻。在 PC 端 px 接近实际的像素点大小，但在移动设备上，根据不同的机型分辨率大小，CSS 的一个 px 会对应不同数量的物理像素点\n\n- 特点：\n\n网页设计的常用单位，也是基本单位。用 px 单位固定设置布局或元素的大小，缺点：没有弹性、大小死板多端的页面无法做到适应的效果。\n\n## 二、%\n\n% 百分比单位\n%一般都是相对于父元素作为基础，例如子元素设置了 50% 指的是 子元素 === 父元素的*50% 也会有几种例外情况：\n- position: absolute // 相对已经定位的父元素\n- position: fixed // 相对于 ViewPort （视口）\n- transorm 2D水平移动变化是相对于自身\n\n## 三、vh\n\nvh CSS3 新单位 view height 的缩写\nvh 类似于 百分比单位，它相对于视窗，它将视窗高度分为100份，1vh 也就是占视窗的1%，举个例子 视窗高度 900px 如果设置 10vh 那么等于 90px\n\n## 四、vw\nvh CSS3 新单位 view width 的缩写\n和 vh 类似不同的是它只是相对于视窗宽度\n\n## 五、vm\n\nvm css3 新单位\n\nvm 也比较简单是指在视口中选取宽度或高度，选择其他最小的一个。然后和 vh 一样将其分为 100 份\n举例: 1200px宽 900px高度的视窗 10vm 就是 90px\n\n## 六、em\n\nem 相对字体大小来计算尺寸。它是相对字体大小的倍数。例如自身设置了 font-size:16px 那么 1em = 16、 10em = 160px。如果使用了 em 单位的元素自身设置字体大小那么相对于自身，如果自身没有设置那么查找父元素是设置。依次向上查找。如果都有没有射中那么使用浏览器默认字体大小 16px 为基准\n\n## 七、rem\n\nrem 和 em 基本类似，只是相对的对象不同。rem 只是会相对 html 根元素的字体大小。如果根元素设置了 字体大小为 20px 那么元素 设置 1rem === 20px\n\n补充：\n1. rem在制作响应式页面中经常使用到，因为我们可以根据不同的设备尺寸，去动态的调整根元素的大小，使用rem单位达到适配不同尺寸设备的效果，有些自适应的页面框架单位上的使用就是基于此种特性\n2. 有时我们为了换算方便会将根元素的字体大小先设置为62.5%，然后根据需要进行调整，原因是62.5%*16px = 10px，此时也就是1rem = 10px\n\n## 八、rpx\nrpx 响应式 px 单位\n由小程序最先提出的响应式px单位，为了解决px在移动端上不同的机型极容易出现的变形问题","tags":["前端基础知识","基础知识"],"categories":["前端基础知识","前端不同单位的区别"]},{"title":"鼠标拖动Div效果","url":"/2021/06/01/鼠标拖动Div效果/","content":"### 上效果图 \n\n![Animation](/images/sbtddiv.gif)\n\n### 本次 demo 用到一些属性\n\n`elment.clientWidth` 获取元素的宽度 包括自身的 `padding` 内容的宽度 不包括边框、返回值不带单位 \n`elment.clientHeight` 获取元素的高度 包括自身的 `padding` 内容的宽度 不包括边框、返回值不带单位 \n\n`element.offsetTop` elment 必须是相对定位的元素 该 API 返回 元素距离父元素上方的距离\n`element.offsetLeft` elment 必须是相对定位的元素 该 API 返回 元素距离父元素左方的距离\n\n- 在看的时候只要看懂一个就很好理解，因为它们是成对出现的\n- 为配合代码理解请看图 需要计算的值 为 4 = 3-(1-2) 这样就计算出来了 4 就是DIV距离父元素的偏移量\n\n![image-20210421161046575](/images/sbdtdiv.png)\n\n- 全部代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .div1 {\n      width: 500px;\n      height: 500px;\n      border: 1px solid red;\n      overflow: hidden;\n      position: relative;\n      margin: 0 auto;\n    }\n    .box {\n      width: 100px;\n      height: 100px;\n      background-color: red;\n      cursor: grab;\n      position: absolute;\n      user-select: none;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"box\">111</div>\n  </div>\n  <script>\n    // 大的DIV\n    let maxBox = document.querySelector('.div1')\n    // 拖动的DIV\n    let box = document.querySelector('.box')\n    // 鼠标是否按下\n    let flag = false\n    // 计算 拖动 div 的范围\n     let maxX = maxBox.clientWidth - box.clientWidth\n     let maxY = maxBox.clientHeight - box.clientHeight\n    //  鼠标按下时鼠标在页面中的位置\n    let ax = 0\n    let ay = 0\n    // 鼠标按下 div 在页面中的偏移量\n    let apx = 0\n    let apy = 0\n    // 鼠标按下\n    box.addEventListener('mousedown', (e)=> {\n      if (!flag) flag = true\n      box.style.cursor = 'grabbing'\n      // console.log(e)\n      ax = e.pageX\n      ay = e.pageY\n      apx = box.offsetLeft\n      apy = box.offsetTop\n    })\n    // 鼠标移动\n    box.addEventListener('mousemove', (e)=> {\n      if (flag) {\n        let offsetX = e.pageX - (ax - apx)\n        let offsetY = e.pageY - (ay - apy)\n        if (offsetX >= maxX || offsetX <= 0) return\n        if (offsetY >= maxY || offsetY <= 0) return\n        box.style.left = offsetX + 'px'\n        box.style.top = offsetY + 'px'\n      }\n    })\n    // 鼠标弹起\n    box.addEventListener('mouseup', ()=> {\n      if (flag) flag = false\n      box.style.cursor = 'grab'\n    })\n  </script>\n</body>\n</html>\n\n```","tags":["纯 JavaScript 小 Demo 练习"],"categories":["前端基础知识","纯 JavaScript 小 Demo 练习","鼠标拖动div的效果"]},{"title":"常用数组方法","url":"/2021/05/10/常用数组方法/","content":"## 常用的数组方法\n说明：\n1. 之前也发过一篇关于<a href=\"https://qingbohu.github.io/2021/05/04/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95/\">常见数组遍历方法的文章</a>，建议结合该篇一起食用效果最佳。\n2. 下面方法将会以是否会改变原数组分类\n### 改变原数组\n#### splice() 添加/删除数组元素\n作用：通过删除或替换新的元素来修改原数组，该方法会修改原数组的指。该方法返回值是被删除的元素组成的数组\n\n语法： `array.splice(start,[deleteCount,item1,item2...])`\n\n参数说明：\n\n- `start` ： 指定修改的位置（从0计数）如果是负数，则表示从数组末尾开始。\n- `deleteCount`：表示要移除的元素个数\n- `[item1,item2...]`：要添加的数组元素，如果不指定则只删除数组元素。\n\n实例\n\n```javascript\nvar array = [1, 2, 3, 4, 5, 6]\nvar arrayReturnedValue = array.splice(0, 2, 10, 20)\nconsole.log(arrayReturnedValue) // outPut: [1,2] 返回了被删除的元素组成的数组\nconsole.log(array) // outPut: [10, 20, 3, 4, 5, 6] 修改了原数组\n```\n#### pop() 删除数组中的最后一个元素\n\n作用： pop() 方法 将会删除数组中的最后一个元素，返回值是被删除的元素\n\n语法： `array.pop()`\n\n实例\n\n```javascript\nvar array = [1, 2, 3]\nconsole.log(array.pop()) // OutPut: 3  返回值是被删除的元素\nconsole.log(array) // OutPut: [1, 2]\n```\n#### shift() 删除数组中的第一个元素\n\n作用：shift() 方法删除数组中的第一个元素，返回值被删除的元素\n\n语法： `array.shift()`\n\n实例\n\n```javasctipt\nvar array = [3, 2, 1]\nconsole.log(array.shift()) // OutPut: 3 返回值被删除的元素\nconsole.log(array) // OutPut: [2, 1] \n```\n#### unshift() 在数组开头添加一个或多个元素\n\n语法： `array.unshift(element1[, element2....])`\n\n作用：unshift() 方法向数组的开头添加一个或多个元素，并返回数组添加后的长度\n\n```javascript\nvar array = [5, 6, 7]\nconsole.log(array.unshift(1, 2, 3, 4))// OutPut: 7\nconsole.log(array) // OutPut: [1, 2, 3, 4, 5, 6, 7]\n```\n\n#### reverse() 将数组倒序\n\n语法： `array.reverse()`\n\n作用：reverse() 方法可以将数组的顺序颠倒 返回值是被颠倒后的数组\n\n实例\n\n```javascript\nvar array = [1, 2, 3, 4, 5, 6]\nconsole.log(array.reverse())// OutPut:[6, 5, 4, 3, 2, 1]\nconsole.log(array)// OutPut:[6, 5, 4, 3, 2, 1]\n```\n---------------------------------------------------------------------华-丽-的-分-割-线--------------------------------------------------------------\n\n### 不改变原数组\n\n#### join() 将数组按照指定分隔符转成字符串\n\n作用：将 数组元素按照指定的分隔符转成字符串，默认是按照 逗号 分隔。\n\n语法： `array.join([*])`\n\n实例\n\n```javascript\nvar array  = ['hello', '您好']\nvar str = array.join() \nconsole.log(str) // hell,您好\nvar str1 = array.join('*')\nconsole.log(str1)// hell*您好\n```\n\n### toString() 将数组转成字符串 不推荐\n\n语法：`array.toString()`\n\n作用： 将数组转成以逗号分隔的字符串，因 toString 只能将数组转成以逗号分隔的字符串不能自定义所以不推荐使用，不如使用 `join()` 来转换。比起起使用 `toString()` 方法，当 数组 和 字符串相连接时数组会转成 以逗号分隔的字符串，这也是不推荐的使用 `toString()` 方法的原因之一。\n\n实例\n\n```javascript\nvar array = [1, 2, 3, '张三']\nconsole.log(array.toString()) // 1,2,3,张三\nconsole.log(array + '')// 1,2,3,张三\n\n```\n\n#### concat() 合并两个数组或多个\n\n作用： 方法合并两个或多个数组，并返回一个新的数组\n\n语法： `array.concat(array1[,array2,array3])`\n\n参数说明： array 和 array1....  代表要合并的数组\n\n实例\n\n```javascript\nvar array1 = [1, 2, 3]\nvar array2 = [3, 4, 5]\nvar array3 = ['六','七','八']\nvar newArray = array1.concat(array2, array3)\nconsole.log(newArray) // OutPut: [1, 2, 3, 3, 4, 5, \"六\", \"七\", \"八\"]\n```\n\n#### indexOf() 查找数组是否含有某元素\n\n作用： indexOf() 可以查找数组中是否含有某个元素，有：返回改元素在数组中的下标，无：返回 -1。 \n\n语法：`array.indexOf(element[,fromIndex])`\n\n参数说明： `element` 代表查找的元素 `fromIndex` 从哪个索引开始查找\n\n实例\n\n```javascript\narray.indexOf(elment, fromIndex)// 语法：element: 查找的元素 fromIndex: 从哪个索引开始查找\nvar array = ['张三', 18, '男']\nconsole.log(array.indexOf('女')) // OutPut： -1\nconsole.log(array.indexOf('男')) // OutPut： 2\nconsole.log(array.indexOf(18, 2))// OutPut -1 数组中有这个元素但是查找的索引是从 2 开始所以查找不到 返回 -1\n\n```\n\n#### lastIndexOf 查找数组是否包含某元素\n\n作用 ： 和 `indexOf` 作用一致用法一致，与之不同的是 lastIndexOf 是倒序查找元素。\n\n#### includes() 查找数组是否包含某元素 返回布尔\n\n作用： includes() 查找数组是否包含某元素 返回布尔\n\n语法：`array.includes(element)`\n\n参数说明： `element` 查找的元素\n\n实例\n\n```javascript\nvar array1 = [1, 2, 3, 4, 5]\nconsole.log(array1.includes(6))// outPut: false\nconsole.log(array1.includes(5))// outPut: true\n```\n#### slice()\n\n作用：浅拷贝数组。`slice()`方法返回一个新的数组对象，这个数组对象由 `start` 和 `end` 决定元素的浅拷贝 (包括 `satrt` 不包括 `end`)\n\n实例：\n\n```js\nconst array = ['ant', 'bison', 'camel', 'duck', 'elephant']\n\nconsole.log(array.slice(2))// ouPut:[\"camel\", \"duck\", \"elephant\"]\n\nconsole.log(animals.slice(2, 4));\n// expected output: Array [\"camel\", \"duck\"]\n```\n\n参数：\n`start`: 提取元素的起始索引，果如出现 `slice(-2)` 代表从数组的 倒数第二个元素开始提取\n\n`end`：提取元素的终止索引\n\n#### sort()\n\n作用：对数组元素进行排序，并返回数组。默认排序顺序是将元素转为字符串然后比较它们的UTF-16代码单元值\n\n实例 ：\n```js\nconst months = ['March', 'Jan', 'Feb', 'Dec'];\nmonths.sort();\nconsole.log(months);\n// expected output: Array [\"Dec\", \"Feb\", \"Jan\", \"March\"]\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n// expected output: Array [1, 100000, 21, 30, 4]\n\n```\n语法： `arr.sort([compareFunction])`\n\n参数：\n1. `compareFunction`： 可选参数 用来指定按照某种顺序进行排列的函数，如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。\n1.1 `firstEl`: 第一个比较的元素\n1.2 `secondEl`: 第二个比较的元素\n\n返回值：排序后的数组，已经原地排序了。改变了原数组。\n\n描述：\n如果指明了 `compareFunction()`,那么数组会按照调用该函数的返回值排序。\n- 如果要比较的是数字而非字符串 `compareFunction(a, b) {return a - b}` 函数会对数组进行升序 \n常用例子：\n```js\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort(function(a, b) {\n  return a - b;\n});\nconsole.log(numbers);\n\n也可以写成：\nvar numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);\n\n// [1, 2, 3, 4, 5]\n\n```\n也可以按照某个属性进行排序\n```js\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic' },\n  { name: 'Zeros', value: 37 }\n];\n\n// sort by value\nitems.sort(function (a, b) {\n  return (a.value - b.value)\n});\n\n// sort by name\nitems.sort(function(a, b) {\n  var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n  var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n  if (nameA < nameB) {\n    return -1;\n  }\n  if (nameA > nameB) {\n    return 1;\n  }\n\n  // names must be equal\n  return 0;\n});\n```","tags":["基础知识","数组方法"],"categories":["前端基础知识","数组相关操作"]},{"title":"无须联网激活系统工具","url":"/2021/05/07/无须联网激活系统工具/","content":"### 软件介绍\nHEU KMS Activator 是一位叫 知彼而知己 的大神所开发的KMS激活工具，最新版本新增加了OEM激活，增加对Vista/Win7/Server 2008 (R2)/2012 (R2) OEM的永久激活(支持Legacy/UEFI BIOS)，此工具可以完美的激活Windows以及Office的VL版本，无需联网即可一键激活，目前最新版的HEU KMS Activator 新增Win10数字许可证激活，不在是以前的那个KMS激活了，很多系统都可以使用数字权利永久激活使用，而且此工具带有静默激活参数可以用来封装使用，在封装系统安装后调用HEU KMS Activator 计划任务 加上静默激活参数可完美激活，此版本激活成功率最高，推荐系统封装爱好者使用，此工具由亿破姐收集整理100%出自“知彼而知己”的正版，无广告，无流氓行为，无捆绑，无后门的激活工具。\n### 下载地址\nhttps://wwr.lanzoui.com/i9ilBowio2f\n密码:gbtz","tags":["工具分享"],"categories":["工具分享","激活软件","Windows无须联网激活工具"]},{"title":"网站使用介绍","url":"/2021/05/06/网站使用介绍/","content":"## 前言\n非常幸运能得到您的访问，希望我的博客能给您带来帮助。在博客我主要分享自己在学习路上所遇到的坎坷、学习笔记分享、常用的工具分享、生活日记等。如果您在使用过程遇到问题或文章中出现错误，欢迎您给你提出宝贵的意见。\n\n\n## 网站使用说明\n\n1. 网站使用 hexo 框架搭建的部署在 github 中\n\n2. 如何查找文章？\n- 点击网站右上角搜索可以对文章进行检索\n![image-20210421161046575](/images/sysm.png)\n3. 首页文章太杂乱了。找不到我想看的类型？\n- 点击网站导航中的 __文章分类__ 可以对文章进行分类查看\n![image-20210421161046575](/images/wzfl.png)\n\n","tags":["网站使用介绍"],"categories":["网站使用介绍"]},{"title":"XMind脑图软件","url":"/2021/05/06/XMind脑图软件/","content":"## 软件介绍\n我经常拿这个软件来记笔记，非常不错的软件，分享给大家。XMind 是一个全功能的思维导图和头脑风暴软件，为激发灵感和创意而生。作为一款有效提升工作和生活效率的生产力工具，受到全球百千万用户的青睐。XMind ZEN具有强大的绘图基础，除了常规的组织结构图、逻辑图、鱼骨图、矩阵图之外，还可以发挥自己的想象力，通过简单的自由主题和主题间的联系，打破思维导图的固有模式，画出极具创意的结构模式。\n## 下载地址\n蓝奏云：\nhttps://wwr.lanzous.com/b0263xa3i\n密码:e0kf","tags":["工具分享"],"categories":["工具分享","办公软件","XMind思维导图软件"]},{"title":"adobe系列软件","url":"/2021/05/06/adobe系列软件/","content":"### 应用介绍\n软件内涵盖所有欧特比系列的全新软件，并贴心的分为大师版光盘镜像和独立版软件，将可独立安装的SP版和体积较大的大师版都打包了进去。所有产品都免激活，集破解补丁于一体，一键安装即可使用，无需复杂的操作，支持自定义选择简体中文、安装路径设置，十分方便。需要注意的是软件因配置需求因素，需要安装在最新的最新的Windows 10系统上面，并需要配置高性能硬盘，并保存足够的剩余空间。小编分享的赢政天下Adobe2021大师版，有专业需求的不妨下载收藏。\n### 下载地址\n链接: https://pan.baidu.com/s/1z4gnkfRA5bMClg-DsKmc5g 提取码: siy7 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","制图工具","Adobe2020全系列软件"]},{"title":"Office系列软件","url":"/2021/05/06/office系列软件/","content":"### 应用介绍\noffice 2019 \n### 下载地址\n链接: https://pan.baidu.com/s/159n4RyG7SGumNvhtCf0fqA 提取码: 4iry 复制这段内容后打开百度网盘手机App，操作更方便哦","tags":["工具分享"],"categories":["工具分享","办公软件","Office 全系列软件"]},{"title":"深入理解原型链与继承","url":"/2021/05/06/深入理解原型链与继承/","content":"## 构造函数、原型对象、实例三者之间的关系\n- 构造函数  =\\=\\=\\= prototype=\\=\\=\\=>  原型对象\n- 原型对象 =\\=\\=\\=constructor =\\=\\=\\=> 构造函数\n- 实例 =\\=\\=\\= \\_\\_proto\\_\\_ =\\=\\=\\=> 原型对象 \n\n借助一张图来理解：\n![image-20210421161046575](/images/yxl.png)\n\n## 重写原型对象\n应用场景：在实现某一功能时，经常会用一个包含所有属性和方法重写整个原型对象。（因为添加的方法或属性很少那么只需要在原型对象上添加。其实在工作中更多的是在原型对象的基础上添加属性或方法，而不重写整个原型对象）\n\n重写整个原型对象：\n```javascript\nPerson.prototype = {\n    name: \"神奇的程序员\",\n    age: \"20\",\n    job: \"web前端开发\",\n    sayName: function () {\n        console.log(this.name);\n    }\n    constructor: Person\n}\n```\n\n在原型对象上添加属性或方法\n```javascript\nPerson.protutypt.name = \"神奇的程序员\"\nPerson.protutypt.age = \"20\"\nPerson.protutypt.sayName = function(){\n\tconsole.log(this.name)\n}\n\n```\n- 两种方法作用其实是一样的。重写整个原型对象如果不手动设置 constructor 属性那么它的 constructor 属性会指向 Object （正常情况应该指向对应的构造函数）\n\n## 原型链\n\n1. 当访问一个对象的成员(属性或方法),首先查找这个对象自身有没有该成员\n2. 在该对象中没有查找该成员,查找在它的原型对象是否有该成员(\\_\\_prototype\\_\\_指向原型对象)\n3. 原型对象上没有查找该成员,在 Object 的原型对象查找\n4. 还是没有找到 返回 Null\n- 以上四部构成了原型链,只要在任意一层找到了就执行该成员,没有都找到返回 Null\n\n## 原型对象继承\n\n- 每个构造函数都有一个原型对象\n- 原型对象都有 constructor 属性它是指向构造函数（被重写原型对象除外，没有手动指回原型对象的，默认指向 Object ）\n- 每个构造函数通过 prototype指向原型对象\n\n原型链继承就是一个构造函数原型对象等于另一个构造函数的实例，此时的原型对象将包含一个指向另一个构造函数原型的指针。下面的例子 Sub 构造函数 的原型对象重写成了 Super 实例。Sub 可以调用调用 Super 的原型对象上的方法，这就组成了一条原型链。 \n\n```javascript\nfunction Super() {\n  this.superStatus = true\n}\n// 在原型对象上添加方法\nSuper.prototype.getSuperStatus = function() {\n  return this.superStatus\n}\nfunction Sub() {\n  this.subStatus = false\n}\n// 在原型对象上添加方法\nSub.prototype.getSubStatus = function() {\n  return this.subStatus\n}\n// 将 Sub 原型对象指向 Super 实例 此时constructor 被重写 指向 Super\nSub.prototype = new Super()\n\n// 实例化 Sub\nvar sub = new Sub()\n// sub 实例没有 getSuperStatus 方法 但是因为我们之前它的原型对象重写指向了 Super \nconsole.log('获取Super的属性值',sub.getSuperStatus()) // outPut: 获取Super的属性值 true\n```\n### 原型链继承存在的问题\nSub 的原型对象重写成 Super 的实例，Sub 继承 Super 的全部属性和方法。我们需求是在 实例 sub1 上添加的数据，但是后面的 sub2 也受到了影响。这就是存在的问题。\n```javascript\nfunction Super() {\n  this.list = [\"a\",\"b\",\"c\"];\n}\n\nfunction Sub() {\n\n}\nSub.prototype = new Super();\nconst sub1 = new Sub();\nsub1.list.push(\"d\");\nconsole.log(sub1.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\nconst sub2 = new Sub();\nconsole.log(sub2.list); // outPut: [\"a\",\"b\",\"c\",\"d\"]\n```\n## 类\n\n在 ES6 之前 JavaScript 是没有类的概念，都是用 构造函数来代替类的作用。类的出现极大的简化操作，\n### 类的语法\n\n- 创建类\n```javascript\n// 创建类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\t// 类的方法\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\nf1 = new Fathe('张三', 20)\nconsole.log(f1.name, f1.age) // outPut: 张三 20\n```\n### 类的继承\n\n构造函数和类的作用都用来实例化对象的。使对象之间有关联性，而类的优点在于更加方便的创建继承，不需要想构造函数那样使用 寄生式继承、修改原型对象指向继承、构造函数静态方法继承。但是 类的底层实现方法还是基于构造函数的方法。\n\n实例\n\n```javascript\n// 创建父类\nclass Fathe{\n\t// 类的属性必须写在 constructor 函数中，该函数可以接收传递过来的参数，同时返回实例对象\n\tconstructor(name, age){\n\t\tthis.name = name\n\t\tthis.age = age\n\t}\n\tsay(){\n\t\tconsole.log(this.name)\n\t}\n}\n// 创建子类 使用 extends 继承父类 \nclass Children extends Fathe {\n  constructor(name,age, sex) {\n    // 继承父类的 ane age 属性 \n      // super 要写 this 最前面\n    super(name, age) \n    this.sex = sex\n  }\n}\n\nvar children1 = new Children('李四', 20, '男')\nchildren1.say()  // 子类调用父类的方法\nconsole.log(children1) \n```\n\n\n\n\n\n\n","tags":["原型链与继承"],"categories":["前端基础知识","原型链与继承"]},{"title":"常见数组遍历方法","url":"/2021/05/04/数组遍历相关的方法/","content":"- 说明：\n1. 书写顺序按实际工作中使用的频率排序。\n2. 参数中出现 [] (中括号) 表示在为可选参数\n3. 建议和<a href=\"https://qingbohu.github.io/2021/05/10/%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/\" >常用数组方法</a>该篇一起食用效果更佳\n\n# 常见的数组遍历方法\n## forEach 方法\nforEach 是最常见的数组遍历方法，使用简单功能单一。就是遍历数组的每一个元素\n### 语法\n全部参数：\n```javascript\narray.forEach(callback(current[, currentIndex, currentArray]){\n  console.log(current)\n}[, thisArg])\n```\n精简参数\n```javascript\narray.forEach(callback(current){\n  console.log(current)\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`forEach` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = ['张三', '李四', '王五']\narray.forEach((current, currentIndex, currentArray)=>{\n    console.log('当前被遍历的元素为：',current)\n    console.log('当前被遍历的元素下标为：',currentIndex)\n    console.log('当前被遍历的元素的数组对象：',currentArray)\n    console.log('回调函数中的this指向为：',this)\n    console.log('-----------------------------')\n},window)\n```\n--------------------------------------------------------------------------------------------------\n## find 和 findIndex 方法\n1. find 方法可以查找数组中第一个符合条件的元素 返回值：查找到的元素。\n2. findeIndex 方法可以查找数组中第一个符合条件的元素  返回值： 符合条件的元素下标\n- 需要注意的是 find 和 findIndex 当查找到符合条件的元素，就会结束查找，所以它只会查找到第一个符合条件的元素，另外它们两个的用法是一样的，只是返回值不一致。\n### 语法\n因为 finde 和 findeIndex 方法用法是一样的那么只演示其中一个\n```javascript\narray.find((current[, currentIndex, currentArray]) => {\n\treturn current > 10 // 条件\n}[,thisAry])\n```\n### 参数说明\nfind 一个接受两个参数 `callback` 和 `thisAry`\n1. `callback` 查找元素是执行的回调函数 注意需要将条件 return\n- `current`: 当前执行回调的元素 \n- `currentIndex`[可选]: 当前执行回调元素的下标\n- `currentArray`[可选]: 当前按执行回调元素的数组\n2. `thisAry`[可选] ： 执行回调函数时的 this 指向\n\n### 实例\n```javascript\nvar array = [7, 8, 20, 40, 50, 60]\nvar result1 = array.find((current) => {\n\treturn current === 20\n})\nvar result2 = array.findIndex((current) => {\n\treturn current === 20\n})\nconsole.log(result1) // outPut: 20 \nconsole.log(result2) // outPut: 2 \n```\n## map 方法\nmap 方法可以用数组元素的映射，该方法不会改变源数组的值返回一个新的数组，参数和 forEach 函数是一样的。区别：因为 map 方法会返回一个全新的数组，那么在回调函数要使用 return 将当前元素返回。 \n### 语法\n全部参数：\n```javascript\narray.map(callback(current[, currentIndex, currentArray]){\n  return current + 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.map(callback(current){\n  return current + 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`map` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\n// 将原来的数组每个元素 + 10 返回\nvar array = [1, 2, 3, 4]\nvar result = array.map((current)=>{\n    return current + 10\n})\nconsole.log(result) // outPut: [11, 12, 13, 14]\n```\n--------------------------------------------------------------------------------------------------\n## filter 方法\nfilter 方法是对数组元素进行筛选，将符合条件的元素返回成一个数组 和 map 方法 用法差不多 都需要 return 它们作用不同\n### 语法\n全部参数：\n```javascript\narray.filter(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.filter(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`filter` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.filter((current)=>{\n    return current > 30\n})\nconsole.log(result) // outPUt: [33, 78, 60]\n```\n---------------------------------------------------------------------------------------------------------\n## some 方法\nsome 方法 测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值, 有无元素符合条件 有:返回 ture 无:返回flase\n### 语法\n全部参数：\n```javascript\narray.some(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.some(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`some` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.some((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: true\n```\n------------------------------------------------------------------------------------------------------\n## every 方法\nevery 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n### 语法\n全部参数：\n```javascript\narray.every(callback(current[, currentIndex, currentArray]){\n  return current > 10\n}[, thisArg])\n```\n精简参数\n```javascript\narray.every(callback(current){\n  return current > 10\n})\n```\n### 参数说明\n别看参数这么多其实实际中用到的参数并不多，这里说明下全部参数，那么精简参数你也自然清楚了。\n`every` 一共接收两个参数 \n\n1. `callback` 回调函数：遍历每个元素时会执行该回调函数 回调函数可以接收 3 个参数\n- `current` 当前被遍历的元素\n- `currentIndex` [可选]  当前被遍历的下标\n- `curentArray` [可选] 当前元素的数组对象\n2. `thisArg` [可选]  callback 的 this 指向\n### 实例\n```javascript\nvar array = [10, 11, 22, 33, 1, 78, 60]\nvar result = array.every((current)=>{\n    return current > 10\n})\nconsole.log(result) // outPut: false\n```\n## reduce 方法\nreduce 方法虽然不常见但是用起来是最爽的一个，应用场景也非常多。例如 数组去重、统计字符出现的次数、扁平化数组。一般用于本次循环结果和下次循环结果有关联的场景。\n### 语法\n全部参数：\n```javascript\narray.reduce((total, current, currentIndex, currentArray) => {\n  return current \n},init)\n\n```\n精简参数：\n```javascript\narray.reduce((total, current) => {\n  return total \n})\n```\n`reduce` 一共接收两个参数 \n1. callback 每个元素执行的回调函数\n- total 累积器\n- current 当前元素\n- currentIndex 当前元素的下标\n- currentArray 当前元素的数组对象\n2. init 第一次执行回调函数时的初始值\n### 实例\n#### 一、数组去重\n```javascript\nvar array = [1, 1, 2, 2, 5, 5, 7, 7, 10, 10]\nvar result = array.reduce((total, current) => {\n    if (!total.includes(current)){\n        total.push(current)\n    }\n    return total\n},[])\nconsole.log(result) // outPut: [1, 2, 5, 7, 10]\n```\n#### 二、统计字符出现的次数\n```javascript\nvar str = 'asdihfsahf;shagfiohsagohsfjsdhfiusgfigasd'\nvar array = str.split('')\nvar result = array.reduce((total, current)=>{\n  if (total[current]) {\n    total[current]++\n  }else{\n    total[current] = 1\n  }\n  return total\n},{})\nconsole.log(result) // outPut: {a: 5, s: 8, d: 3, i: 4, h: 6, …} \n```","tags":["基础知识","数组遍历"],"categories":["前端基础知识","数组相关操作"]},{"title":"关于我","url":"/2021/05/01/关于我/","content":"### 首先非常感谢您阅读我的文章，世界之大能让您能看到我荣幸之至。\n### 个人标签：\n男、九九后、处女座、较真、正直、强迫症\n### 爱好：\n篮球、游戏、爬山、逛大佬博客网站、听前辈讲故事、用技术解决问题\n### 个人简介\n  目前在职 Web前端开发，真的十分庆幸能在自己喜欢的工作岗位上工作。首先感谢我的爸妈，这么多年对我的培养，虽然他们知识文化不高但是却给了我很好的生活和选择的权力，其次感恩老师，在叛逆期是老师的孜孜不倦的教诲才让我没有走错路，当很多人放弃了你却还有那么一个老师对你另眼相看给了你信心。在技术路上对我提供帮助的老师，通过你们的课程让我对技术有很多认识。\n\n  关于我：我一个非常简单的人，正如一个 API 你对我的输入，我也将会输出。性格开朗活泼，对技术充满向往和好奇。路漫漫其修远兮，吾将上下而求索。\n","tags":["关于我"],"categories":["生活日记"]}]